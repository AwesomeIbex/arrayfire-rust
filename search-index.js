var N=null,E="",T="t",U="u",searchIndex={};
var R=["DEFAULT","32 bit float","32 bit complex float","64 bit float","64 bit complex float","8 bit boolean","32 bit signed integer","32 bit unsigned integer","8 bit unsigned integer","64 bit signed integer","64 bit unsigned integer","16 bit signed integer","16 bit unsigned integer","Quadratic flux function","Sort the values in input Arrays","binaryop","backend","hasafenum","Element wise conditional operator for Arrays","Inplace replace in Array based on a condition","string","interptype","bordertype","momenttype","matprop","Solve a system of equations","randomengine","convmode","convdomain","complex","sparseformat","features","matchtype","elements","option","markertype","randomenginetype","get_type","Get random engine type","set_seed","get_seed","indexer","This type alias points to a data type that can store the…","is_complex","Trait qualifier for given type indicating computability of…","Trait qualifier for type of Array's that are accepted by…","join_many","to_owned","clone_into","try_from","try_into","borrow_mut","result","type_id","to_string","borrow","typeid","aferror","connectivity","colorspace","normtype","colormap","homographytype","cannythresholdtype","diffusioneq","formatter","fmterror","is_real","Use to check if trait implementor is real number","Use to check if trait implementor is complex number","InterpType","BorderType","Connectivity","ConvMode","ConvDomain","MatchType","ColorSpace","NormType","ColorMap","HomographyType","MarkerType","MomentType","SparseFormat","BinaryOp","RandomEngineType","CannyThresholdType","DiffusionEq","Callback","RandomEngine","Features","Convertable","ConstGenerator","Indexable","HasAfEnum","ImplicitPromote","FloatingPoint"];

searchIndex["arrayfire"]={"doc":"ArrayFire is a high performance software library for…","i":[[3,"Array","arrayfire","A multidimensional data container",N,N],[3,"Dim4",E,"Dim4 is used to store Array dimensions",N,N],[3,R[87],E,"Structure holding handle to callback function",N,N],[3,"Indexer",E,"Struct to manage an array of resources of type…",N,N],[3,"Seq",E,"Sequences are used for indexing Arrays",N,N],[3,"Window",E,"Used to render Array objects",N,N],[3,R[88],E,"Random number generator engine",N,N],[3,R[89],E,"A set of Array objects (usually, used in Computer vision…",N,N],[4,"AfError",E,"Error codes",N,N],[13,"SUCCESS",E,"The function returned successfully",0,N],[13,"ERR_NO_MEM",E,"The system or device ran out of memory",0,N],[13,"ERR_DRIVER",E,"There was an error in the device driver",0,N],[13,"ERR_RUNTIME",E,"There was an error with the runtime environment",0,N],[13,"ERR_INVALID_ARRAY",E,"The input array is not a valid Array object",0,N],[13,"ERR_ARG",E,"One of the function arguments is incorrect",0,N],[13,"ERR_SIZE",E,"The size is incorrect",0,N],[13,"ERR_TYPE",E,"The type is not suppported by this function",0,N],[13,"ERR_DIFF_TYPE",E,"The type of the input arrays are not compatible",0,N],[13,"ERR_BATCH",E,"Function does not support GFOR / batch mode",0,N],[13,"ERR_DEVICE",E,"Input does not belong to the current device",0,N],[13,"ERR_NOT_SUPPORTED",E,"The option is not supported",0,N],[13,"ERR_NOT_CONFIGURED",E,"This build of ArrayFire does not support this feature",0,N],[13,"ERR_NO_DBL",E,"This device does not support double",0,N],[13,"ERR_NO_GFX",E,"This build of ArrayFire was not built with graphics or…",0,N],[13,"ERR_INTERNAL",E,"There was an internal error either in ArrayFire or in a…",0,N],[13,"ERR_UNKNOWN",E,"Unknown Error",0,N],[4,"Backend",E,"Compute/Acceleration Backend",N,N],[13,R[0],E,"Default backend order: OpenCL -> CUDA -> CPU",1,N],[13,"CPU",E,"CPU a.k.a sequential algorithms",1,N],[13,"CUDA",E,"CUDA Compute Backend",1,N],[13,"OPENCL",E,"OpenCL Compute Backend",1,N],[4,"DType",E,"Types of Array data type",N,N],[13,"F32",E,R[1],2,N],[13,"C32",E,R[2],2,N],[13,"F64",E,R[3],2,N],[13,"C64",E,R[4],2,N],[13,"B8",E,R[5],2,N],[13,"S32",E,R[6],2,N],[13,"U32",E,R[7],2,N],[13,"U8",E,R[8],2,N],[13,"S64",E,R[9],2,N],[13,"U64",E,R[10],2,N],[13,"S16",E,R[11],2,N],[13,"U16",E,R[12],2,N],[4,R[70],E,"Dictates the interpolation method to be used by a function",N,N],[13,"NEAREST",E,"Nearest Neighbor interpolation method",3,N],[13,"LINEAR",E,"Linear interpolation method",3,N],[13,"BILINEAR",E,"Bilinear interpolation method",3,N],[13,"CUBIC",E,"Cubic interpolation method",3,N],[13,"LOWER",E,"Floor indexed",3,N],[13,"LINEAR_COSINE",E,"Linear interpolation with cosine smoothing",3,N],[13,"BILINEAR_COSINE",E,"Bilinear interpolation with cosine smoothing",3,N],[13,"BICUBIC",E,"Bicubic interpolation",3,N],[13,"CUBIC_SPLINE",E,"Cubic interpolation with Catmull-Rom splines",3,N],[13,"BICUBIC_SPLINE",E,"Bicubic interpolation with Catmull-Rom splines",3,N],[4,R[71],E,"Helps determine how to pad kernels along borders",N,N],[13,"ZERO",E,"Pad using zeros",4,N],[13,"SYMMETRIC",E,"Pad using mirrored values along border",4,N],[4,R[72],E,"Used by `regions` function to identify type of connectivity",N,N],[13,"FOUR",E,"North-East-South-West (N-E-S-W) connectivity from given…",5,N],[13,"EIGHT",E,"N-NE-E-SE-S-SW-W-NW connectivity from given pixel/point",5,N],[4,R[73],E,"Helps determine the size of output of convolution",N,N],[13,R[0],E,"Default convolution mode where output size is same as…",6,N],[13,"EXPAND",E,"Output of convolution is expanded based on signal and…",6,N],[4,R[74],E,"Helps determine if convolution is in Spatial or Frequency…",N,N],[13,"AUTO",E,"ArrayFire chooses whether the convolution will be in…",7,N],[13,"SPATIAL",E,"Convoltion in spatial domain",7,N],[13,"FREQUENCY",E,"Convolution in frequency domain",7,N],[4,R[75],E,"Error metric used by `matchTemplate` function",N,N],[13,"SAD",E,"Sum of Absolute Differences",8,N],[13,"ZSAD",E,"Zero-mean Sum of Absolute Differences",8,N],[13,"LSAD",E,"Locally scaled Sum of Absolute Differences",8,N],[13,"SSD",E,"Sum of Squared Differences",8,N],[13,"ZSSD",E,"Zero-mean Sum of Squared Differences",8,N],[13,"LSSD",E,"Localy scaled Sum of Squared Differences",8,N],[13,"NCC",E,"Normalized Cross Correlation",8,N],[13,"ZNCC",E,"Zero-mean Normalized Cross Correlation",8,N],[13,"SHD",E,"Sum of Hamming Distances",8,N],[4,R[76],E,"Identify the color space of given image(Array)",N,N],[13,"GRAY",E,"Grayscale color space",9,N],[13,"RGB",E,"Red-Green-Blue color space",9,N],[13,"HSV",E,"Hue-Saturation-value color space",9,N],[4,"MatProp",E,"Helps determine the type of a Matrix",N,N],[13,"NONE",E,"Default (no-op)",10,N],[13,"TRANS",E,"Data needs to be transposed",10,N],[13,"CTRANS",E,"Data needs to be conjugate transposed",10,N],[13,"UPPER",E,"Matrix is upper triangular",10,N],[13,"LOWER",E,"Matrix is lower triangular",10,N],[13,"DIAGUNIT",E,"Matrix diagonal has unitary values",10,N],[13,"SYM",E,"Matrix is symmetric",10,N],[13,"POSDEF",E,"Matrix is positive definite",10,N],[13,"ORTHOG",E,"Matrix is orthogonal",10,N],[13,"TRIDIAG",E,"Matrix is tri-diagonal",10,N],[13,"BLOCKDIAG",E,"Matrix is block-diagonal",10,N],[4,R[77],E,"Norm type",N,N],[13,"VECTOR_1",E,"Treats input as a vector and return sum of absolute values",11,N],[13,"VECTOR_INF",E,"Treats input as vector and return max of absolute values",11,N],[13,"VECTOR_2",E,"Treats input as vector and returns euclidean norm",11,N],[13,"VECTOR_P",E,"Treats input as vector and returns the p-norm",11,N],[13,"MATRIX_1",E,"Return the max of column sums",11,N],[13,"MATRIX_INF",E,"Return the max of row sums",11,N],[13,"MATRIX_2",E,"Returns the max singular value (Currently not supported)",11,N],[13,"MATRIX_L_PQ",E,"Returns Lpq-norm",11,N],[4,R[78],E,"Dictates what color map is used for Image rendering",N,N],[13,R[0],E,"Default color map is grayscale range [0-1]",12,N],[13,"SPECTRUM",E,"Visible spectrum color map",12,N],[13,"COLORS",E,"Colors",12,N],[13,"RED",E,"Red hue map",12,N],[13,"MOOD",E,"Mood color map",12,N],[13,"HEAT",E,"Heat color map",12,N],[13,"BLUE",E,"Blue hue map",12,N],[4,"YCCStd",E,"YCbCr Standards",N,N],[13,"YCC_601",E,"ITU-R BT.601 (formerly CCIR 601) standard",13,N],[13,"YCC_709",E,"ITU-R BT.709 standard",13,N],[13,"YCC_2020",E,"ITU-R BT.2020 standard",13,N],[4,R[79],E,"Homography type",N,N],[13,"RANSAC",E,"RANdom SAmple Consensus algorithm",14,N],[13,"LMEDS",E,"Least Median of Squares",14,N],[4,R[80],E,"Plotting markers",N,N],[13,"NONE",E,"No marker",15,N],[13,"POINT",E,"Pointer marker",15,N],[13,"CIRCLE",E,"Hollow circle marker",15,N],[13,"SQUARE",E,"Hollow Square marker",15,N],[13,"TRIANGLE",E,"Hollow Triangle marker",15,N],[13,"CROSS",E,"Cross-hair marker",15,N],[13,"PLUS",E,"Plus symbol marker",15,N],[13,"STAR",E,"Start symbol marker",15,N],[4,R[81],E,"Image moment types",N,N],[13,"M00",E,"Central moment of order (0 + 0)",16,N],[13,"M01",E,"Central moment of order (0 + 1)",16,N],[13,"M10",E,"Central moment of order (1 + 0)",16,N],[13,"M11",E,"Central moment of order (1 + 1)",16,N],[13,"FIRST_ORDER",E,"All central moments of order (0,0), (0,1), (1,0) and (1,1)",16,N],[4,R[82],E,"Sparse storage format type",N,N],[13,"DENSE",E,"Dense format",17,N],[13,"CSR",E,"Compressed sparse row format",17,N],[13,"CSC",E,"Compressed sparse coloumn format",17,N],[13,"COO",E,"Coordinate list (row, coloumn, value) tuples.",17,N],[4,R[83],E,"Binary operation types for generalized scan functions",N,N],[13,"ADD",E,"Addition operation",18,N],[13,"MUL",E,"Multiplication operation",18,N],[13,"MIN",E,"Minimum operation",18,N],[13,"MAX",E,"Maximum operation",18,N],[4,R[84],E,"Random engine types",N,N],[13,"PHILOX_4X32_10",E,"Philox variant with N=4, W=32 and Rounds=10",19,N],[13,"THREEFRY_2X32_16",E,"Threefry variant with N=2, W=32 and Rounds=16",19,N],[13,"MERSENNE_GP11213",E,"Mersenne variant with MEXP = 11213",19,N],[4,"Scalar",E,"Scalar value types",N,N],[13,"F32",E,R[1],20,N],[13,"C32",E,R[2],20,N],[13,"F64",E,R[3],20,N],[13,"C64",E,R[4],20,N],[13,"B8",E,R[5],20,N],[13,"S32",E,R[6],20,N],[13,"U32",E,R[7],20,N],[13,"U8",E,R[8],20,N],[13,"S64",E,R[9],20,N],[13,"U64",E,R[10],20,N],[13,"S16",E,R[11],20,N],[13,"U16",E,R[12],20,N],[4,R[85],E,"Canny edge detector threshold operations types",N,N],[13,"MANUAL",E,"User has to define canny thresholds manually",21,N],[13,"OTSU",E,"Determine canny algorithm high threshold using Otsu…",21,N],[4,R[86],E,"Anisotropic diffusion flux equation types",N,N],[13,"QUADRATIC",E,R[13],22,N],[13,"EXPONENTIAL",E,"Exponential flux function",22,N],[13,R[0],E,"Default flux function, a.k.a exponential",22,N],[4,"FluxFn",E,"Diffusion equation types",N,N],[13,"GRADIENT",E,R[13],23,N],[13,"MCDE",E,"Modified curvature diffusion equation",23,N],[13,R[0],E,"Default diffusion method, Gradient",23,N],[4,"TopkFn",E,"topk function ordering",N,N],[13,"MIN",E,"Top k min values",24,N],[13,"MAX",E,"Top k max values",24,N],[13,R[0],E,"Default option(max)",24,N],[5,"print",E,"Print data in the Array",N,[[["array"]]]],[5,"print_gen",E,"Generalized Array print function",N,[[[R[20]],["i32"],["array"],[R[34],["i32"]]]]],[5,"eval_multiple",E,"evaluate multiple arrays",N,[[["vec",["array"]],["array"]]]],[5,"set_manual_eval",E,"Set eval flag value",N,[[["bool"]]]],[5,"is_eval_manual",E,"Get eval flag value",N,[[],["bool"]]],[5,"sum",E,"Sum elements along a given dimension",N,[[["array"],["i32"]],["array"]]],[5,"product",E,"Compute product of elements along a given dimension",N,[[["array"],["i32"]],["array"]]],[5,"min",E,"Find minimum among elements of given dimension",N,[[["array"],["i32"]],["array"]]],[5,"max",E,"Find maximum among elements of given dimension",N,[[["array"],["i32"]],["array"]]],[5,"all_true",E,"Find if all of the values along a given dimension in the…",N,[[["array"],["i32"]],[["array",["bool"]],["bool"]]]],[5,"any_true",E,"Find if any of the values along a given dimension in the…",N,[[["array"],["i32"]],[["array",["bool"]],["bool"]]]],[5,"count",E,"Count number of non-zero elements along a given dimension",N,[[["array"],["i32"]],[["u32"],["array",["u32"]]]]],[5,"accum",E,"Perform exclusive sum of elements along a given dimension",N,[[["array"],["i32"]],["array"]]],[5,"diff1",E,"Calculate first order numerical difference along a given…",N,[[["array"],["i32"]],["array"]]],[5,"diff2",E,"Calculate second order numerical difference along a given…",N,[[["array"],["i32"]],["array"]]],[5,"sum_nan",E,"Sum along specific dimension using user specified value…",N,[[["array"],["f64"],["i32"]],["array"]]],[5,"product_nan",E,"Product of elements along specific dimension using user…",N,[[["array"],["f64"],["i32"]],["array"]]],[5,"sum_all",E,"Sum all values of the Array",N,[[["array"]]]],[5,"product_all",E,"Product of all values of the Array",N,[[["array"]]]],[5,"min_all",E,"Find minimum among all values of the Array",N,[[["array"]]]],[5,"max_all",E,"Find maximum among all values of the Array",N,[[["array"]]]],[5,"all_true_all",E,"Find if all values of Array are non-zero",N,[[["array"]]]],[5,"any_true_all",E,"Find if any value of Array is non-zero",N,[[["array"]]]],[5,"count_all",E,"Count number of non-zero values in the Array",N,[[["array"]]]],[5,"sum_nan_all",E,"Sum all values using user provided value for `NAN`",N,[[["array"],["f64"]]]],[5,"product_nan_all",E,"Product of all values using user provided value for `NAN`",N,[[["array"],["f64"]]]],[5,"imin",E,"Find minimum value along given dimension and their…",N,[[["array"],["i32"]]]],[5,"imax",E,"Find maximum value along given dimension and their…",N,[[["array"],["i32"]]]],[5,"imin_all",E,"Find minimum and it's index in the whole Array",N,[[["array"]]]],[5,"imax_all",E,"Find maximum and it's index in the whole Array",N,[[["array"]]]],[5,"locate",E,"Locate the indices of non-zero elements.",N,[[["array"]],[["u32"],["array",["u32"]]]]],[5,"sort",E,R[14],N,[[["array"],["u32"],["bool"]],["array"]]],[5,"sort_index",E,R[14],N,[[["array"],["u32"],["bool"]]]],[5,"sort_by_key",E,R[14],N,[[["u32"],["array"],["array"],["bool"]]]],[5,"set_unique",E,"Find unique values from a Set",N,[[["array"],["bool"]],["array"]]],[5,"set_union",E,"Find union of two sets",N,[[["array"],["bool"]],["array"]]],[5,"set_intersect",E,"Find intersection of two sets",N,[[["array"],["bool"]],["array"]]],[5,"scan",E,"Generalized scan",N,[[[R[15]],["i32"],["array"],["bool"]],["array"]]],[5,"scan_by_key",E,"Generalized scan by key",N,[[[R[15]],["array"],["i32"],["array"],["bool"]],["array"]]],[5,"abs",E,"Computes absolute value",N,[[["array"]],["array"]]],[5,"arg",E,"Computes phase value",N,[[["array"]],["array"]]],[5,"trunc",E,"Truncate the values in an Array",N,[[["array"]],["array"]]],[5,"sign",E,"Computes the sign of input Array values",N,[[["array"]],["array"]]],[5,"round",E,"Round the values in an Array",N,[[["array"]],["array"]]],[5,"floor",E,"Floor the values in an Array",N,[[["array"]],["array"]]],[5,"ceil",E,"Ceil the values in an Array",N,[[["array"]],["array"]]],[5,"sigmoid",E,"Compute sigmoid function",N,[[["array"]],["array"]]],[5,"expm1",E,"Compute e raised to the power of value -1",N,[[["array"]],["array"]]],[5,"erf",E,"Compute error function value",N,[[["array"]],["array"]]],[5,"erfc",E,"Compute the complementary error function value",N,[[["array"]],["array"]]],[5,"log10",E,"Compute logarithm base 10",N,[[["array"]],["array"]]],[5,"log1p",E,"Compute the logarithm of input Array + 1",N,[[["array"]],["array"]]],[5,"log2",E,"Compute logarithm base 2",N,[[["array"]],["array"]]],[5,"cbrt",E,"Compute the cube root",N,[[["array"]],["array"]]],[5,"tgamma",E,"Compute gamma function",N,[[["array"]],["array"]]],[5,"lgamma",E,"Compute the logarithm of absolute values of gamma function",N,[[["array"]],["array"]]],[5,"acosh",E,"Compute acosh",N,[[["array"]],["array"]]],[5,"acos",E,"Compute acos",N,[[["array"]],["array"]]],[5,"asin",E,"Compute asin",N,[[["array"]],["array"]]],[5,"asinh",E,"Compute asinh",N,[[["array"]],["array"]]],[5,"atan",E,"Compute atan",N,[[["array"]],["array"]]],[5,"atanh",E,"Compute atanh",N,[[["array"]],["array"]]],[5,"cos",E,"Compute cos",N,[[["array"]],["array"]]],[5,"cosh",E,"Compute cosh",N,[[["array"]],["array"]]],[5,"exp",E,"Compute e raised to the power of value",N,[[["array"]],["array"]]],[5,"log",E,"Compute the natural logarithm",N,[[["array"]],["array"]]],[5,"sin",E,"Compute sin",N,[[["array"]],["array"]]],[5,"sinh",E,"Compute sinh",N,[[["array"]],["array"]]],[5,"sqrt",E,"Compute the square root",N,[[["array"]],["array"]]],[5,"tan",E,"Compute tan",N,[[["array"]],["array"]]],[5,"tanh",E,"Compute tanh",N,[[["array"]],["array"]]],[5,"real",E,"Extract real values from a complex Array",N,[[["array"]],["array"]]],[5,"imag",E,"Extract imaginary values from a complex Array",N,[[["array"]],["array"]]],[5,"cplx",E,"Create a complex Array from real Array",N,[[["array"]],["array"]]],[5,"conjg",E,"Compute the complex conjugate",N,[[["array"]],["array"]]],[5,"pow2",E,"Compute two raised to the power of value",N,[[["array"]],["array"]]],[5,"factorial",E,"Compute the factorial",N,[[["array"]],["array"]]],[5,"iszero",E,"Check if values are zero",N,[[["array"]],[["array",["bool"]],["bool"]]]],[5,"isinf",E,"Check if values are infinity",N,[[["array"]],[["array",["bool"]],["bool"]]]],[5,"isnan",E,"Check if values are NaN",N,[[["array"]],[["array",["bool"]],["bool"]]]],[5,"bitand",E,"Elementwise AND(bit) operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"bitor",E,"Elementwise OR(bit) operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"bitxor",E,"Elementwise XOR(bit) operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"neq",E,"Elementwise not equals comparison of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"and",E,"Elementwise logical and operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"or",E,"Elementwise logical or operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"minof",E,"Elementwise minimum operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"maxof",E,"Elementwise maximum operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"hypot",E,"Compute length of hypotenuse of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"add",E,"Addition of two Arrays",N,[[[T],[U],["bool"]],["array"]]],[5,"sub",E,"Subtraction of two Arrays",N,[[[T],[U],["bool"]],["array"]]],[5,"mul",E,"Multiplication of two Arrays",N,[[[T],[U],["bool"]],["array"]]],[5,"div",E,"Division of two Arrays",N,[[[T],[U],["bool"]],["array"]]],[5,"rem",E,"Compute remainder from two Arrays",N,[[[T],[U],["bool"]],["array"]]],[5,"shiftl",E,"Compute left shift",N,[[[T],[U],["bool"]],["array"]]],[5,"shiftr",E,"Compute right shift",N,[[[T],[U],["bool"]],["array"]]],[5,"modulo",E,"Compute modulo of two Arrays",N,[[[T],[U],["bool"]],["array"]]],[5,"atan2",E,"Calculate atan2 of two Arrays",N,[[[T],[U],["bool"]],["array"]]],[5,"cplx2",E,"Create complex array from two Arrays",N,[[[T],[U],["bool"]],["array"]]],[5,"root",E,"Compute root",N,[[[T],[U],["bool"]],["array"]]],[5,"pow",E,"Computer power",N,[[[T],[U],["bool"]],["array"]]],[5,"lt",E,"Perform `less than` comparison operation",N,[[[T],[U],["bool"]],[["array",["bool"]],["bool"]]]],[5,"gt",E,"Perform `greater than` comparison operation",N,[[[T],[U],["bool"]],[["array",["bool"]],["bool"]]]],[5,"le",E,"Perform `less than equals` comparison operation",N,[[[T],[U],["bool"]],[["array",["bool"]],["bool"]]]],[5,"ge",E,"Perform `greater than equals` comparison operation",N,[[[T],[U],["bool"]],[["array",["bool"]],["bool"]]]],[5,"eq",E,"Perform `equals` comparison operation",N,[[[T],[U],["bool"]],[["array",["bool"]],["bool"]]]],[5,"clamp",E,"Clamp the values of Array",N,[[["array"],["c"],["bool"]],["array"]]],[5,"set_backend",E,"Toggle backends between cuda, opencl or cpu",N,[[[R[16]]]]],[5,"get_backend_count",E,"Get the available backend count",N,[[],["u32"]]],[5,"get_available_backends",E,"Get the available backends",N,[[],[["vec",[R[16]]],[R[16]]]]],[5,"get_active_backend",E,"Get current active backend",N,[[],[R[16]]]],[5,"matmul",E,"Matrix multiple of two Arrays",N,[[["array"],[R[24]]],["array"]]],[5,"dot",E,"Calculate the dot product of vectors.",N,[[["array"],[R[24]]],["array"]]],[5,"transpose",E,"Transpose of a matrix.",N,[[["array"],["bool"]],[["array"],[R[17]]]]],[5,"transpose_inplace",E,"Inplace transpose of a matrix.",N,[[["array"],["bool"]]]],[5,"constant",E,"Create an Array with constant value",N,[[["dim4"],["constgenerator"]],["array"]]],[5,"range",E,"Create a Range of values",N,[[["dim4"],["i32"]],[["array"],[R[17]]]]],[5,"iota",E,"Create a range of values",N,[[["dim4"]],[["array"],[R[17]]]]],[5,"identity",E,"Create an identity array with 1's in diagonal",N,[[["dim4"]],[["array"],[R[17]]]]],[5,"diag_create",E,"Create a diagonal matrix",N,[[["array"],["i32"]],["array"]]],[5,"diag_extract",E,"Extract diagonal from a given Matrix",N,[[["array"],["i32"]],["array"]]],[5,"join",E,"Join two arrays",N,[[["array"],["i32"]],["array"]]],[5,R[46],E,"Join multiple arrays",N,[[["vec",["array"]],["array"],["i32"]],["array"]]],[5,"tile",E,"Tile the input array along specified dimension",N,[[["array"],["dim4"]],["array"]]],[5,"reorder",E,"Reorder the array in specified order",N,[[["array"],["dim4"]],["array"]]],[5,"shift",E,"\"Circular shift of values along specified dimension",N,[[["array"]],["array"]]],[5,"moddims",E,"Change the shape of the Array",N,[[["array"],["dim4"]],["array"]]],[5,"flat",E,"Flatten the multidimensional Array to an 1D Array",N,[[["array"]],["array"]]],[5,"flip",E,"Flip the Array",N,[[["array"],["u32"]],["array"]]],[5,"lower",E,"Create lower triangular matrix",N,[[["array"],["bool"]],["array"]]],[5,"upper",E,"Create upper triangular matrix",N,[[["array"],["bool"]],["array"]]],[5,"select",E,R[18],N,[[["array"],["array"]],["array"]]],[5,"selectl",E,R[18],N,[[["array"],["f64"],["array"]],["array"]]],[5,"selectr",E,R[18],N,[[["array"],["f64"],["array"]],["array"]]],[5,"replace",E,R[19],N,[[["array"],["array"],["array"]]]],[5,"replace_scalar",E,R[19],N,[[["array"],["array"],["f64"]]]],[5,"get_version",E,"Get ArrayFire Version Number",N,[[]]],[5,"get_revision",E,"Get ArrayFire Revision (commit) information of the library.",N,[[],[["cow",["str"]],["str"]]]],[5,"info",E,"Print library meta-info",N,[[]]],[5,"info_string",E,"Return library meta-info as `String`",N,[[["bool"]],[R[20]]]],[5,"device_info",E,"Gets the information about device and platform as strings.",N,[[]]],[5,"init",E,"Initialize ArrayFire library",N,[[]]],[5,"device_count",E,"Get total number of available devices",N,[[],["i32"]]],[5,"is_double_available",E,"Check if a device has double support",N,[[["i32"]],["bool"]]],[5,"set_device",E,"Set active device",N,[[["i32"]]]],[5,"get_device",E,"Get the current active device id",N,[[],["i32"]]],[5,"device_mem_info",E,"Get memory information from the memory manager for the…",N,[[]]],[5,"print_mem_info",E,"Print buffer details from the ArrayFire device manager",N,[[[R[20]],["i32"]]]],[5,"set_mem_step_size",E,"Set the minimum memory chunk size",N,[[["usize"]]]],[5,"get_mem_step_size",E,"Get the minimum memory chunk size",N,[[],["usize"]]],[5,"device_gc",E,"Call the garbage collection routine",N,[[]]],[5,"sync",E,"Sync all operations on given device",N,[[["i32"]]]],[5,"handle_error_general",E,"Default error handling callback provided by ArrayFire crate",N,[[[R[57]]]]],[5,"register_error_handler",E,"Register user provided error handler",N,[[["callback"]]]],[5,"index",E,"Indexes the `input` Array using `seqs` Sequences",N,[[["array"]],["array"]]],[5,"row",E,"Extract `row_num` row from `input` Array",N,[[["array"],["u64"]],["array"]]],[5,"set_row",E,"Set `row_num`^th row in `input` Array to a new Array…",N,[[["array"],["u64"]],["array"]]],[5,"rows",E,"Get an Array with all rows from `first` to `last` in the…",N,[[["array"],["u64"]],["array"]]],[5,"set_rows",E,"Set rows from `first` to `last` in `input` Array with rows…",N,[[["array"],["u64"]],["array"]]],[5,"col",E,"Extract `col_num` col from `input` Array",N,[[["array"],["u64"]],["array"]]],[5,"set_col",E,"Set `col_num`^th col in `input` Array to a new Array…",N,[[["array"],["u64"]],["array"]]],[5,"cols",E,"Get all cols from `first` to `last` in the `input` Array",N,[[["array"],["u64"]],["array"]]],[5,"set_cols",E,"Set cols from `first` to `last` in `input` Array with cols…",N,[[["array"],["u64"]],["array"]]],[5,"slice",E,"Get `slice_num`^th slice from `input` Array",N,[[["array"],["u64"]],["array"]]],[5,"set_slice",E,"Set slice `slice_num` in `input` Array to a new Array…",N,[[["array"],["u64"]],["array"]]],[5,"slices",E,"Get slices from `first` to `last` in `input` Array",N,[[["array"],["u64"]],["array"]]],[5,"set_slices",E,"Set `first` to `last` slices of `input` Array to a new…",N,[[["array"],["u64"]],["array"]]],[5,"lookup",E,"Lookup(hash) an Array using another Array",N,[[["array"],["array"],["i32"]],["array"]]],[5,"assign_seq",E,"Assign(copy) content of an Array to another Array indexed…",N,[[["array"]],["array"]]],[5,"index_gen",E,"Index an Array using any combination of Array's and…",N,[[["array"],[R[41]]],["array"]]],[5,"assign_gen",E,"Assign an Array to another after indexing it using any…",N,[[["array"],[R[41]]],["array"]]],[5,"gradient",E,"Calculate the gradients",N,[[["array"]]]],[5,"load_image",E,"Load Image into Array",N,[[[R[20]],["bool"]],["array"]]],[5,"load_image_native",E,"Load Image into Array in it's native type",N,[[[R[20]]],["array"]]],[5,"save_image",E,"Save an Array to an image file",N,[[["array"],[R[20]]]]],[5,"save_image_native",E,"Save an Array without modifications to an image file",N,[[["array"],[R[20]]]]],[5,"resize",E,"Resize an Image",N,[[["array"],["i64"],[R[21]]],[["array"],[R[17]]]]],[5,"transform",E,"Transform(Affine) an Image",N,[[["i64"],["array"],[R[21]],["array"],["bool"]],[["array"],[R[17]]]]],[5,"rotate",E,"Rotate an Image",N,[[[R[21]],["array"],["f64"],["bool"]],[["array"],[R[17]]]]],[5,"translate",E,"Translate an Image",N,[[["f32"],["i64"],[R[21]],["array"]],[["array"],[R[17]]]]],[5,"scale",E,"Scale an Image",N,[[["f32"],["i64"],[R[21]],["array"]],[["array"],[R[17]]]]],[5,"skew",E,"Skew an image",N,[[["f32"],["i64"],[R[21]],["array"],["bool"]],[["array"],[R[17]]]]],[5,"histogram",E,"Compute Histogram of an Array",N,[[["u32"],["array"],["f64"]],[["u32"],["array",["u32"]]]]],[5,"dilate",E,"Dilate an Image",N,[[["array"]],["array"]]],[5,"erode",E,"Erode an Image",N,[[["array"]],["array"]]],[5,"dilate3",E,"Dilate a Volume",N,[[["array"]],["array"]]],[5,"erode3",E,"Erode a Volume",N,[[["array"]],["array"]]],[5,"bilateral",E,"Bilateral Filter.",N,[[["array"],["f32"],["bool"]],["array"]]],[5,"mean_shift",E,"Meanshift Filter.",N,[[["f32"],["u32"],["array"],["bool"]],["array"]]],[5,"medfilt",E,"Median filter",N,[[["array"],[R[22]],["u64"]],["array"]]],[5,"minfilt",E,"Box filter with minimum as box operation",N,[[["array"],[R[22]],["u64"]],["array"]]],[5,"maxfilt",E,"Box filter with maximum as box operation",N,[[["array"],[R[22]],["u64"]],["array"]]],[5,"gaussian_kernel",E,"Creates a Gaussian Kernel.",N,[[["f64"],["i32"]],[["f32"],["array",["f32"]]]]],[5,"color_space",E,"Color space conversion",N,[[["array"],[R[59]]],["array"]]],[5,"regions",E,"Find blobs in given image.",N,[[[R[58]],["array"]],["array"]]],[5,"sobel",E,"Sobel Operator",N,[[["array"],["u32"]]]],[5,"hist_equal",E,"Histogram Equalization",N,[[["array"],["array"]],["array"]]],[5,"rgb2gray",E,"Color(RGB) to Grayscale conversion",N,[[["array"],["f32"]],["array"]]],[5,"gray2rgb",E,"Grayscale to Color(RGB) conversion",N,[[["array"],["f32"]],["array"]]],[5,"hsv2rgb",E,"HSV to RGB color space conversion",N,[[["array"]],["array"]]],[5,"rgb2hsv",E,"RGB to HSV color space conversion",N,[[["array"]],["array"]]],[5,"unwrap",E,"Generate an array with image windows as columns",N,[[["array"],["i64"],["bool"]],[["array"],[R[17]]]]],[5,"wrap",E,"Converts unwrapped image to an image",N,[[["array"],["i64"],["bool"]],[["array"],[R[17]]]]],[5,"sat",E,"Summed area table of an Image",N,[[["array"]],["array"]]],[5,"rgb2ycbcr",E,"RGB to YCbCr colorspace converter.",N,[[["array"],["yccstd"]],["array"]]],[5,"ycbcr2rgb",E,"YCbCr to RGB colorspace converter.",N,[[["array"],["yccstd"]],["array"]]],[5,"is_imageio_available",E,"Function to check if Image I/O is available",N,[[],["bool"]]],[5,"transform_coords",E,"Transform input coordinates",N,[[["array"],["f32"]],["array"]]],[5,"moments",E,"Find Image moments",N,[[["array"],[R[23]]],[["f32"],["array",["f32"]]]]],[5,"moments_all",E,"Find Image moment for whole image",N,[[["array"],[R[23]]],["f64"]]],[5,"medfilt1",E,"One dimensional median filter on image",N,[[["array"],[R[22]],["u64"]],["array"]]],[5,"canny",E,"Canny edge detection operator",N,[[["f32"],["u32"],["array"],[R[63]],["bool"]],[["array",["bool"]],["bool"]]]],[5,"anisotropic_diffusion",E,"Anisotropic smoothing filter",N,[[["f32"],["u32"],[R[64]],["array"],["fluxfn"]],["array"]]],[5,"svd",E,"Perform Singular Value Decomposition",N,[[["array"]]]],[5,"svd_inplace",E,"Perform Singular Value Decomposition inplace",N,[[["array"]]]],[5,"lu",E,"Perform LU decomposition",N,[[["array"]]]],[5,"lu_inplace",E,"Perform inplace LU decomposition",N,[[["array"],["bool"]],[["array",["i32"]],["i32"]]]],[5,"qr",E,"Perform QR decomposition",N,[[["array"]]]],[5,"qr_inplace",E,"Perform inplace QR decomposition",N,[[["array"]],["array"]]],[5,"cholesky",E,"Perform Cholesky decomposition",N,[[["array"],["bool"]]]],[5,"cholesky_inplace",E,"Perform inplace Cholesky decomposition",N,[[["array"],["bool"]],["i32"]]],[5,"solve",E,R[25],N,[[["array"],[R[24]]],["array"]]],[5,"solve_lu",E,R[25],N,[[["array"],[R[24]],["array"]],["array"]]],[5,"inverse",E,"Compute inverse of a matrix",N,[[["array"],[R[24]]],["array"]]],[5,"rank",E,"Find rank of a matrix",N,[[["array"],["f64"]],["u32"]]],[5,"det",E,"Find the determinant of the matrix",N,[[["array"]]]],[5,"norm",E,"Find the norm of a matrix",N,[[[R[60]],["array"],["f64"]],["f64"]]],[5,"is_lapack_available",E,"Function to check if lapack support is available",N,[[],["bool"]]],[5,R[39],E,"Set seed for random number generation",N,[[["u64"]]]],[5,R[40],E,"Get the seed of random number generator",N,[[],["u64"]]],[5,"randu",E,"Create random numbers from uniform distribution",N,[[["dim4"]],["array"]]],[5,"randn",E,"Create random numbers from normal distribution",N,[[["dim4"]],["array"]]],[5,"get_default_random_engine",E,"Get default random engine",N,[[],[R[26]]]],[5,"set_default_random_engine_type",E,"Set the random engine type for default random number…",N,[[[R[36]]]]],[5,"random_uniform",E,"Generate array of uniform numbers using a random engine",N,[[["dim4"],[R[26]]],["array"]]],[5,"random_normal",E,"Generate array of normal numbers using a random engine",N,[[["dim4"],[R[26]]],["array"]]],[5,"approx1",E,"Perform signal interpolation for 1d signals",N,[[["array"],[R[21]],["f32"],["array"]],["array"]]],[5,"approx2",E,"Perform signal interpolation for 2d signals",N,[[["array"],[R[21]],["f32"],["array"]],["array"]]],[5,"set_fft_plan_cache_size",E,"Set fft plan cache size",N,[[["usize"]]]],[5,"fft",E,"Fast fourier transform for 1d signals",N,[[["array"],["f64"],["i64"]],["array"]]],[5,"fft2",E,"Fast fourier transform for 2d signals",N,[[["i64"],["array"],["f64"]],["array"]]],[5,"fft3",E,"Fast fourier transform for 3d signals",N,[[["i64"],["array"],["f64"]],["array"]]],[5,"ifft",E,"Inverse fast fourier transform for 1d signals",N,[[["array"],["f64"],["i64"]],["array"]]],[5,"ifft2",E,"Inverse fast fourier transform for 2d signals",N,[[["i64"],["array"],["f64"]],["array"]]],[5,"ifft3",E,"Inverse fast fourier transform for 3d signals",N,[[["i64"],["array"],["f64"]],["array"]]],[5,"convolve1",E,"1d convolution",N,[[[R[27]],["array"],["array"],[R[28]]],["array"]]],[5,"convolve2",E,"2d convolution",N,[[[R[27]],["array"],["array"],[R[28]]],["array"]]],[5,"convolve3",E,"3d convolution",N,[[[R[27]],["array"],["array"],[R[28]]],["array"]]],[5,"convolve2_sep",E,"Separable convolution for 2d signals",N,[[["array"],["array"],[R[27]]],["array"]]],[5,"fft_convolve1",E,"1d convolution using fast-fourier transform",N,[[["array"],["array"],[R[27]]],["array"]]],[5,"fft_convolve2",E,"2d convolution using fast-fourier transform",N,[[["array"],["array"],[R[27]]],["array"]]],[5,"fft_convolve3",E,"3d convolution using fast-fourier transform",N,[[["array"],["array"],[R[27]]],["array"]]],[5,"fir",E,"Finite impulse filter",N,[[["array"],["array"]],["array"]]],[5,"iir",E,"Infinite impulse response filter",N,[[["array"]],[["array"],[R[17]]]]],[5,"fft_inplace",E,"In place 1d dimensional Fast fourier transform",N,[[["array"],["f64"]]]],[5,"fft2_inplace",E,"In place 2d dimensional Fast fourier transform",N,[[["array"],["f64"]]]],[5,"fft3_inplace",E,"In place 3d dimensional Fast fourier transform",N,[[["array"],["f64"]]]],[5,"ifft_inplace",E,"In place 1d dimensional inverse fast fourier transform",N,[[["array"],["f64"]]]],[5,"ifft2_inplace",E,"In place 2d dimensional inverse fast fourier transform",N,[[["array"],["f64"]]]],[5,"ifft3_inplace",E,"In place 3d dimensional inverse fast fourier transform",N,[[["array"],["f64"]]]],[5,"fft_r2c",E,"1d Real to Complex fast fourier transform",N,[[["array"],["f64"],["i64"]],[["array",[R[29]]],[R[29]]]]],[5,"fft2_r2c",E,"2d Real to Complex fast fourier transform",N,[[["i64"],["array"],["f64"]],[["array",[R[29]]],[R[29]]]]],[5,"fft3_r2c",E,"3d Real to Complex fast fourier transform",N,[[["i64"],["array"],["f64"]],[["array",[R[29]]],[R[29]]]]],[5,"fft_c2r",E,"1d Complex to Real fast fourier transform",N,[[["array"],["f64"],["bool"]],["array"]]],[5,"fft2_c2r",E,"2d Complex to Real fast fourier transform",N,[[["array"],["f64"],["bool"]],["array"]]],[5,"fft3_c2r",E,"3d Complex to Real fast fourier transform",N,[[["array"],["f64"],["bool"]],["array"]]],[5,"sparse",E,"Create sprase matrix from arrays",N,[[[R[30]],["array"],["array"],["u64"]],["array"]]],[5,"sparse_from_host",E,"Create sprase matrix from data on host memory",N,[[[R[30]],["u64"]],["array"]]],[5,"sparse_from_dense",E,"Convert dense array to sparse array",N,[[["array"],[R[30]]],["array"]]],[5,"sparse_convert_to",E,"Convert between sparse formats",N,[[["array"],[R[30]]],["array"]]],[5,"sparse_to_dense",E,"Convert sparse array to dense array",N,[[["array"]],["array"]]],[5,"sparse_get_info",E,"Get sparse Array information",N,[[["array"]]]],[5,"sparse_get_values",E,"Get values of sparse Array",N,[[["array"]],["array"]]],[5,"sparse_get_row_indices",E,"Get row indices Array",N,[[["array"]],[["array",["i32"]],["i32"]]]],[5,"sparse_get_col_indices",E,"Get cololumn indices Array",N,[[["array"]],[["array",["i32"]],["i32"]]]],[5,"sparse_get_nnz",E,"Get number of non-zero elements in sparse array",N,[[["array"]],["i64"]]],[5,"sparse_get_format",E,"Get sparse format",N,[[["array"]],[R[30]]]],[5,"median",E,"Find the median along a given dimension",N,[[["array"],["i64"]],["array"]]],[5,"mean",E,"Mean along specified dimension",N,[[["array"],["i64"]],["array"]]],[5,"stdev",E,"Standard deviation along specified dimension",N,[[["array"],["i64"]],["array"]]],[5,"mean_weighted",E,"Weighted mean along specified dimension",N,[[["array"],["i64"],["array"]],["array"]]],[5,"var_weighted",E,"Weight variance along specified dimension",N,[[["array"],["i64"],["array"]],["array"]]],[5,"var",E,"Compute Variance along a specific dimension",N,[[["array"],["i64"],["bool"]],["array"]]],[5,"cov",E,"Compute covariance of two Arrays",N,[[["array"],["bool"]],["array"]]],[5,"var_all",E,"Compute Variance of all elements",N,[[["array"],["bool"]]]],[5,"mean_all",E,"Compute mean of all data",N,[[["array"]]]],[5,"stdev_all",E,"Compute standard deviation of all data",N,[[["array"]]]],[5,"median_all",E,"Compute median of all data",N,[[["array"]]]],[5,"mean_all_weighted",E,"Compute weighted mean of all data",N,[[["array"],["array"]]]],[5,"var_all_weighted",E,"Compute weighted variance of all data",N,[[["array"],["array"]]]],[5,"corrcoef",E,"Compute correlation coefficient",N,[[["array"]]]],[5,"topk",E,"Find top k elements along a given dimension",N,[[["u32"],["i32"],["array"],["topkfn"]]]],[5,"get_size",E,"Get size, in bytes, of the arrayfire native type",N,[[["dtype"]],["usize"]]],[5,"fast",E,"Fast feature detector",N,[[["f32"],["u32"],["array"],["bool"]],[R[31]]]],[5,"harris",E,"Harris corner detector.",N,[[["f32"],["u32"],["array"]],[R[31]]]],[5,"orb",E,"ORB feature descriptor",N,[[["f32"],["u32"],["array"],["bool"]]]],[5,"hamming_matcher",E,"Hamming feature matcher",N,[[["array"],["i64"],["u32"]]]],[5,"nearest_neighbour",E,"Nearest Neighbour.",N,[[["i64"],["u32"],["array"],[R[32]]]]],[5,"match_template",E,"Image matching",N,[[["array"],[R[32]]],["array"]]],[5,"susan",E,"SUSAN corner detector.",N,[[["f32"],["u32"],["array"]],[R[31]]]],[5,"dog",E,"Difference of Gaussians.",N,[[["array"],["i32"]],["array"]]],[5,"homography",E,"Homography estimation",N,[[["f32"],["array"],["u32"],[R[62]]]]],[11,"new",E,"Constructs a new Array object",25,[[["dim4"]],["self"]]],[11,"new_strided",E,"Constructs a new Array object from strided data",25,[[["i64"],["dim4"]],["self"]]],[11,"new_empty",E,"Constructs a new Array object of specified dimensions and…",25,[[["dim4"]],["self"]]],[11,"get_backend",E,"Returns the backend of the Array",25,[[["self"]],[R[16]]]],[11,"get_device_id",E,"Returns the device identifier(integer) on which the Array…",25,[[["self"]],["i32"]]],[11,R[33],E,"Returns the number of elements in the Array",25,[[["self"]],["usize"]]],[11,R[37],E,"Returns the Array data type",25,[[["self"]],["dtype"]]],[11,"dims",E,"Returns the dimensions of the Array",25,[[["self"]],["dim4"]]],[11,"strides",E,"Returns the strides of the Array",25,[[["self"]],["dim4"]]],[11,"numdims",E,"Returns the number of dimensions of the Array",25,[[["self"]],["u32"]]],[11,"offset",E,"Returns the offset to the pointer from where data begins",25,[[["self"]],["i64"]]],[11,"get",E,"Returns the native FFI handle for Rust object `Array`",25,[[["self"]],["i64"]]],[11,"host",E,"Copies the data from the Array to the mutable slice `data`",25,[[["self"]]]],[11,"eval",E,"Evaluates any pending lazy expressions that represent the…",25,[[["self"]]]],[11,"copy",E,"Makes an copy of the Array",25,[[["self"]],["self"]]],[11,"is_empty",E,"Check if Array is empty",25,[[["self"]],["bool"]]],[11,"is_scalar",E,"Check if Array is scalar",25,[[["self"]],["bool"]]],[11,"is_row",E,"Check if Array is a row",25,[[["self"]],["bool"]]],[11,"is_column",E,"Check if Array is a column",25,[[["self"]],["bool"]]],[11,"is_vector",E,"Check if Array is a vector",25,[[["self"]],["bool"]]],[11,R[43],E,"Check if Array is of complex type",25,[[["self"]],["bool"]]],[11,"is_double",E,"Check if Array's numerical type is of double precision",25,[[["self"]],["bool"]]],[11,"is_single",E,"Check if Array's numerical type is of single precision",25,[[["self"]],["bool"]]],[11,R[67],E,"Check if Array is of real type",25,[[["self"]],["bool"]]],[11,"is_floating",E,"Check if Array is of single precision",25,[[["self"]],["bool"]]],[11,"is_integer",E,"Check if Array is of integral type",25,[[["self"]],["bool"]]],[11,"is_bool",E,"Check if Array is of boolean type",25,[[["self"]],["bool"]]],[11,"is_linear",E,"Check if Array's memory layout is continuous and one…",25,[[["self"]],["bool"]]],[11,"is_owner",E,"Check if Array's memory is owned by it and not a view of…",25,[[["self"]],["bool"]]],[11,"cast",E,"Cast the Array data type to `target_type`",25,[[["self"]],[["array"],[R[17]]]]],[11,"is_sparse",E,"Find if the current array is sparse",25,[[["self"]],["bool"]]],[11,"lock",E,"Lock the device buffer in the memory manager",25,[[["self"]]]],[11,"unlock",E,"Unlock the device buffer in the memory manager",25,[[["self"]]]],[11,"device_ptr",E,"Get the device pointer and lock the buffer in memory manager",25,[[["self"]],["u64"]]],[11,"get_allocated_bytes",E,"Get the size of physical allocated bytes.",25,[[["self"]],["usize"]]],[11,"new",E,"Create Dim4 object",26,[[],["self"]]],[11,R[33],E,"Get the number of elements represented by Dim4 object",26,[[["self"]],["u64"]]],[11,"ndims",E,"Get the number of dimensions of Dim4",26,[[["self"]],["usize"]]],[11,"get",E,"Get the dimensions as a slice of 4 values",26,[[["self"]]]],[11,"new",E,"Associated function to create a new Callback object",27,[[["errorcallback"]],["self"]]],[11,"call",E,"call invokes the error callback with `error_code`.",27,[[["self"],[R[57]]]]],[11,"new",E,"Create a new Indexer object and set the dimension specific…",28,[[],["self"]]],[11,"set_index",E,"Set either Array or Seq to index an Array along `idx`…",28,[[["bool"],["u32"],["self"],[R[34],["bool"]],[T]]]],[11,"len",E,"Get number of indexing objects set",28,[[["self"]],["usize"]]],[11,"get",E,"Get native(ArrayFire) resource handle",28,[[["self"]],["i64"]]],[11,"new",E,"Create a `Seq` that goes from `begin` to `end` at a step…",29,[[[T]],["self"]]],[11,"begin",E,"Get begin index of Seq",29,[[["self"]],[T]]],[11,"end",E,"Get end index of Seq",29,[[["self"]],[T]]],[11,"step",E,"Get step size of Seq",29,[[["self"]],[T]]],[11,"new",E,"Creates new Window object",30,[[[R[20]],["i32"]],["self"]]],[11,"set_position",E,"Set window starting position on the screen",30,[[["self"],["u32"]]]],[11,"set_title",E,"Set window title",30,[[["self"],[R[20]]]]],[11,"set_visibility",E,"Set window visibility",30,[[["self"],["bool"]]]],[11,"set_size",E,"Set window size",30,[[["self"],["u32"]]]],[11,"set_colormap",E,"Set color map to be used for rendering image, it can take…",30,[[["self"],[R[61]]]]],[11,"is_closed",E,"Returns true if the window close is triggered by the user",30,[[["self"]],["bool"]]],[11,"grid",E,"Setup display layout in multiview mode",30,[[["self"],["i32"]]]],[11,"show",E,"Used in multiview mode to swap back buffer with front…",30,[[["self"]]]],[11,"set_view",E,"Set the current sub-region to render",30,[[["self"],["i32"]]]],[11,"set_axes_titles",E,"Set chart axes titles",30,[[["self"],[R[20]]]]],[11,"set_axes_limits_compute",E,"Set chart axes limits by computing limits from data",30,[[["self"],[R[34],["array"]],["array"],["bool"]]]],[11,"set_axes_limits_2d",E,"Set 2d chart axes limits",30,[[["self"],["f32"],["bool"]]]],[11,"set_axes_limits_3d",E,"Set 3d chart axes limits",30,[[["self"],["f32"],["bool"]]]],[11,"draw_image",E,"Render given Array as an image",30,[[[R[34],[R[20]]],[R[20]],["array"],["self"]]]],[11,"draw_plot2",E,"Render given two Array's `x` and `y` as a 2d line plot",30,[[[R[34],[R[20]]],[R[20]],["array"],["self"]]]],[11,"draw_plot3",E,"Render given Array's `x`, `y` and `z` as a 3d line plot",30,[[[R[34],[R[20]]],[R[20]],["array"],["self"]]]],[11,"draw_plot",E,"Render give Arrays of points as a 3d line plot",30,[[[R[34],[R[20]]],[R[20]],["array"],["self"]]]],[11,"draw_hist",E,"Render given Array as a histogram",30,[[[R[34],[R[20]]],[R[20]],["array"],["self"],["f64"]]]],[11,"draw_surface",E,"Render give Arrays as 3d surface",30,[[[R[34],[R[20]]],[R[20]],["array"],["self"]]]],[11,"draw_scatter2",E,"Render given Arrays as 2d scatter plot",30,[[[R[34],[R[20]]],[R[20]],["array"],["self"],[R[35]]]]],[11,"draw_scatter3",E,"Render given Arrays as 3d scatter plot",30,[[[R[34],[R[20]]],[R[20]],["array"],["self"],[R[35]]]]],[11,"draw_scatter",E,"Render give Array as 3d scatter plot",30,[[[R[34],[R[20]]],[R[20]],["array"],["self"],[R[35]]]]],[11,"draw_vector_field2",E,"Render given Arrays as 2d vector field",30,[[[R[34],[R[20]]],[R[20]],["array"],["self"]]]],[11,"draw_vector_field3",E,"Render given Arrays as 3d vector field",30,[[[R[34],[R[20]]],[R[20]],["array"],["self"]]]],[11,"draw_vector_field",E,"Render given Array as vector field",30,[[[R[34],[R[20]]],[R[20]],["array"],["self"]]]],[11,"new",E,"Create a new random engine object",31,[[[R[34],["u64"]],[R[36]],["u64"]],["self"]]],[11,R[37],E,R[38],31,[[["self"]],[R[36]]]],[11,"set_type",E,R[38],31,[[["self"],[R[36]]]]],[11,R[39],E,"Set seed for random engine",31,[[["self"],["u64"]]]],[11,R[40],E,"Get seed of the random engine",31,[[["self"]],["u64"]]],[11,"get",E,"Returns the native FFI handle for Rust object `RandomEngine`",31,[[["self"]],["i64"]]],[11,"new",E,"Create and return an object of type Features",32,[[["u64"]],["self"]]],[11,"num_features",E,"Get total number of features found",32,[[["self"]],["i64"]]],[11,"xpos",E,"Get x coordinates Array",32,[[["self"]],[["f32"],["array",["f32"]]]]],[11,"ypos",E,"Get y coordinates Array",32,[[["self"]],[["f32"],["array",["f32"]]]]],[11,"score",E,"Get score Array",32,[[["self"]],[["f32"],["array",["f32"]]]]],[11,"orientation",E,"Get orientation Array",32,[[["self"]],[["f32"],["array",["f32"]]]]],[11,"size",E,"Get features size Array",32,[[["self"]],[["f32"],["array",["f32"]]]]],[11,"get",E,"Get the internal handle for Features object",32,[[["self"]],["i64"]]],[6,"ErrorCallback",E,"Signature of error handling callback function",N,N],[17,"PHILOX",E,"Default Philon RandomEngine that points to PHILOX_4X32_10",N,N],[17,"THREEFRY",E,"Default Threefry RandomEngine that points to…",N,N],[17,"MERSENNE",E,"Default Mersenne RandomEngine that points to…",N,N],[17,"DEFAULT_RANDOM_ENGINE",E,"Default RandomEngine that defaults to PHILOX",N,N],[8,R[90],E,"Type Trait to convert to an Array",N,N],[16,"OutType",E,"This type alias always points to `Self` which is the type…",33,N],[10,"convert",E,"Get an Array of implementors type",33,[[["self"]],["array"]]],[8,R[91],E,"Type Trait to generate a constant Array of given size",N,N],[16,"OutType",E,"The type of Array object returned by generate function",34,N],[10,"generate",E,"Create an Array of `dims` size from scalar value `self`.",34,[[["dim4"],["self"]],["array"]]],[8,R[92],E,"Trait bound indicating indexability",N,N],[10,"set",E,"Set indexing object for a given dimension",35,[[["bool"],["u32"],[R[34],["bool"]],["self"],[R[41]]]]],[8,R[93],E,"Types of the data that can be generated using ArrayFire…",N,N],[16,"InType",E,"This type alias points to `Self` always.",36,N],[16,"BaseType",E,"This type alias points to the data type used to hold real…",36,N],[16,"AbsOutType",E,"This type alias points to `f32` for all 32 bit size types…",36,N],[16,"ArgOutType",E,"This type alias points to `f64`/`f32` for floating point…",36,N],[16,"UnaryOutType",E,"This type alias is used to define the output Array type…",36,N],[16,"ComplexOutType",E,"This type alias points to complex type created from a…",36,N],[16,"MeanOutType",E,R[42],36,N],[16,"AggregateOutType",E,R[42],36,N],[16,"SobelOutType",E,"This type alias points to the output type for given input…",36,N],[10,"get_af_dtype",E,"Return trait implmentors corresponding DType",36,[[],["dtype"]]],[8,R[94],E,"This is an internal trait defined and implemented by…",N,N],[16,"Output",E,"This type alias points to the type of the result obtained…",37,N],[8,"ComplexFloating",E,"Trait qualifier to accept complex data(numbers)",N,N],[8,R[95],E,"Trait qualifier to accept either real or complex typed data",N,N],[11,R[67],E,R[68],38,[[],["bool"]]],[11,R[43],E,R[69],38,[[],["bool"]]],[8,"RealFloating",E,"Trait qualifier to accept real data(numbers)",N,N],[8,"RealNumber",E,"Trait qualifier indicating it can hold real numbers only",N,N],[8,"CovarianceComputable",E,R[44],N,N],[8,"EdgeComputable",E,"Trait qualifier for given type indicating if edge…",N,N],[8,"MedianComputable",E,R[44],N,N],[8,"MomentsComputable",E,R[44],N,N],[8,"GrayRGBConvertible",E,"Trait qualifier for given type indicating conversion…",N,N],[8,"ImageFilterType",E,R[45],N,N],[8,"ImageNativeType",E,R[45],N,N],[8,"Scanable",E,"Trait qualifier for the type of Arrays accepted by scan…",N,N],[14,"mem_info",E,"Macro to print the current stats of ArrayFire's memory…",N,N],[14,R[46],E,"Join multiple Arrays along a given dimension",N,N],[14,"af_print",E,"Print given message before printing out the Array to…",N,N],[14,"eval",E,"Evaluate arbitrary number of arrays",N,N],[11,"from",E,E,25,[[[T]],[T]]],[11,"into",E,E,25,[[],[U]]],[11,R[47],E,E,25,[[["self"]],[T]]],[11,R[48],E,E,25,[[[T],["self"]]]],[11,R[49],E,E,25,[[[U]],[R[52]]]],[11,R[50],E,E,25,[[],[R[52]]]],[11,R[51],E,E,25,[[["self"]],[T]]],[11,R[55],E,E,25,[[["self"]],[T]]],[11,R[53],E,E,25,[[["self"]],[R[56]]]],[11,R[54],E,E,26,[[["self"]],[R[20]]]],[11,"from",E,E,26,[[[T]],[T]]],[11,"into",E,E,26,[[],[U]]],[11,R[47],E,E,26,[[["self"]],[T]]],[11,R[48],E,E,26,[[[T],["self"]]]],[11,R[49],E,E,26,[[[U]],[R[52]]]],[11,R[50],E,E,26,[[],[R[52]]]],[11,R[51],E,E,26,[[["self"]],[T]]],[11,R[55],E,E,26,[[["self"]],[T]]],[11,R[53],E,E,26,[[["self"]],[R[56]]]],[11,"from",E,E,27,[[[T]],[T]]],[11,"into",E,E,27,[[],[U]]],[11,R[49],E,E,27,[[[U]],[R[52]]]],[11,R[50],E,E,27,[[],[R[52]]]],[11,R[51],E,E,27,[[["self"]],[T]]],[11,R[55],E,E,27,[[["self"]],[T]]],[11,R[53],E,E,27,[[["self"]],[R[56]]]],[11,"from",E,E,28,[[[T]],[T]]],[11,"into",E,E,28,[[],[U]]],[11,R[49],E,E,28,[[[U]],[R[52]]]],[11,R[50],E,E,28,[[],[R[52]]]],[11,R[51],E,E,28,[[["self"]],[T]]],[11,R[55],E,E,28,[[["self"]],[T]]],[11,R[53],E,E,28,[[["self"]],[R[56]]]],[11,R[54],E,E,29,[[["self"]],[R[20]]]],[11,"from",E,E,29,[[[T]],[T]]],[11,"into",E,E,29,[[],[U]]],[11,R[47],E,E,29,[[["self"]],[T]]],[11,R[48],E,E,29,[[[T],["self"]]]],[11,R[49],E,E,29,[[[U]],[R[52]]]],[11,R[50],E,E,29,[[],[R[52]]]],[11,R[51],E,E,29,[[["self"]],[T]]],[11,R[55],E,E,29,[[["self"]],[T]]],[11,R[53],E,E,29,[[["self"]],[R[56]]]],[11,"from",E,E,30,[[[T]],[T]]],[11,"into",E,E,30,[[],[U]]],[11,R[47],E,E,30,[[["self"]],[T]]],[11,R[48],E,E,30,[[[T],["self"]]]],[11,R[49],E,E,30,[[[U]],[R[52]]]],[11,R[50],E,E,30,[[],[R[52]]]],[11,R[51],E,E,30,[[["self"]],[T]]],[11,R[55],E,E,30,[[["self"]],[T]]],[11,R[53],E,E,30,[[["self"]],[R[56]]]],[11,"from",E,E,31,[[[T]],[T]]],[11,"into",E,E,31,[[],[U]]],[11,R[47],E,E,31,[[["self"]],[T]]],[11,R[48],E,E,31,[[[T],["self"]]]],[11,R[49],E,E,31,[[[U]],[R[52]]]],[11,R[50],E,E,31,[[],[R[52]]]],[11,R[51],E,E,31,[[["self"]],[T]]],[11,R[55],E,E,31,[[["self"]],[T]]],[11,R[53],E,E,31,[[["self"]],[R[56]]]],[11,"from",E,E,32,[[[T]],[T]]],[11,"into",E,E,32,[[],[U]]],[11,R[47],E,E,32,[[["self"]],[T]]],[11,R[48],E,E,32,[[[T],["self"]]]],[11,R[49],E,E,32,[[[U]],[R[52]]]],[11,R[50],E,E,32,[[],[R[52]]]],[11,R[51],E,E,32,[[["self"]],[T]]],[11,R[55],E,E,32,[[["self"]],[T]]],[11,R[53],E,E,32,[[["self"]],[R[56]]]],[11,R[54],E,E,0,[[["self"]],[R[20]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,"into",E,E,0,[[],[U]]],[11,R[47],E,E,0,[[["self"]],[T]]],[11,R[48],E,E,0,[[[T],["self"]]]],[11,R[49],E,E,0,[[[U]],[R[52]]]],[11,R[50],E,E,0,[[],[R[52]]]],[11,R[51],E,E,0,[[["self"]],[T]]],[11,R[55],E,E,0,[[["self"]],[T]]],[11,R[53],E,E,0,[[["self"]],[R[56]]]],[11,R[54],E,E,1,[[["self"]],[R[20]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,"into",E,E,1,[[],[U]]],[11,R[47],E,E,1,[[["self"]],[T]]],[11,R[48],E,E,1,[[[T],["self"]]]],[11,R[49],E,E,1,[[[U]],[R[52]]]],[11,R[50],E,E,1,[[],[R[52]]]],[11,R[51],E,E,1,[[["self"]],[T]]],[11,R[55],E,E,1,[[["self"]],[T]]],[11,R[53],E,E,1,[[["self"]],[R[56]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,"into",E,E,2,[[],[U]]],[11,R[47],E,E,2,[[["self"]],[T]]],[11,R[48],E,E,2,[[[T],["self"]]]],[11,R[49],E,E,2,[[[U]],[R[52]]]],[11,R[50],E,E,2,[[],[R[52]]]],[11,R[51],E,E,2,[[["self"]],[T]]],[11,R[55],E,E,2,[[["self"]],[T]]],[11,R[53],E,E,2,[[["self"]],[R[56]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,"into",E,E,3,[[],[U]]],[11,R[47],E,E,3,[[["self"]],[T]]],[11,R[48],E,E,3,[[[T],["self"]]]],[11,R[49],E,E,3,[[[U]],[R[52]]]],[11,R[50],E,E,3,[[],[R[52]]]],[11,R[51],E,E,3,[[["self"]],[T]]],[11,R[55],E,E,3,[[["self"]],[T]]],[11,R[53],E,E,3,[[["self"]],[R[56]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,"into",E,E,4,[[],[U]]],[11,R[47],E,E,4,[[["self"]],[T]]],[11,R[48],E,E,4,[[[T],["self"]]]],[11,R[49],E,E,4,[[[U]],[R[52]]]],[11,R[50],E,E,4,[[],[R[52]]]],[11,R[51],E,E,4,[[["self"]],[T]]],[11,R[55],E,E,4,[[["self"]],[T]]],[11,R[53],E,E,4,[[["self"]],[R[56]]]],[11,"from",E,E,5,[[[T]],[T]]],[11,"into",E,E,5,[[],[U]]],[11,R[47],E,E,5,[[["self"]],[T]]],[11,R[48],E,E,5,[[[T],["self"]]]],[11,R[49],E,E,5,[[[U]],[R[52]]]],[11,R[50],E,E,5,[[],[R[52]]]],[11,R[51],E,E,5,[[["self"]],[T]]],[11,R[55],E,E,5,[[["self"]],[T]]],[11,R[53],E,E,5,[[["self"]],[R[56]]]],[11,"from",E,E,6,[[[T]],[T]]],[11,"into",E,E,6,[[],[U]]],[11,R[47],E,E,6,[[["self"]],[T]]],[11,R[48],E,E,6,[[[T],["self"]]]],[11,R[49],E,E,6,[[[U]],[R[52]]]],[11,R[50],E,E,6,[[],[R[52]]]],[11,R[51],E,E,6,[[["self"]],[T]]],[11,R[55],E,E,6,[[["self"]],[T]]],[11,R[53],E,E,6,[[["self"]],[R[56]]]],[11,"from",E,E,7,[[[T]],[T]]],[11,"into",E,E,7,[[],[U]]],[11,R[47],E,E,7,[[["self"]],[T]]],[11,R[48],E,E,7,[[[T],["self"]]]],[11,R[49],E,E,7,[[[U]],[R[52]]]],[11,R[50],E,E,7,[[],[R[52]]]],[11,R[51],E,E,7,[[["self"]],[T]]],[11,R[55],E,E,7,[[["self"]],[T]]],[11,R[53],E,E,7,[[["self"]],[R[56]]]],[11,"from",E,E,8,[[[T]],[T]]],[11,"into",E,E,8,[[],[U]]],[11,R[47],E,E,8,[[["self"]],[T]]],[11,R[48],E,E,8,[[[T],["self"]]]],[11,R[49],E,E,8,[[[U]],[R[52]]]],[11,R[50],E,E,8,[[],[R[52]]]],[11,R[51],E,E,8,[[["self"]],[T]]],[11,R[55],E,E,8,[[["self"]],[T]]],[11,R[53],E,E,8,[[["self"]],[R[56]]]],[11,"from",E,E,9,[[[T]],[T]]],[11,"into",E,E,9,[[],[U]]],[11,R[47],E,E,9,[[["self"]],[T]]],[11,R[48],E,E,9,[[[T],["self"]]]],[11,R[49],E,E,9,[[[U]],[R[52]]]],[11,R[50],E,E,9,[[],[R[52]]]],[11,R[51],E,E,9,[[["self"]],[T]]],[11,R[55],E,E,9,[[["self"]],[T]]],[11,R[53],E,E,9,[[["self"]],[R[56]]]],[11,"from",E,E,10,[[[T]],[T]]],[11,"into",E,E,10,[[],[U]]],[11,R[47],E,E,10,[[["self"]],[T]]],[11,R[48],E,E,10,[[[T],["self"]]]],[11,R[49],E,E,10,[[[U]],[R[52]]]],[11,R[50],E,E,10,[[],[R[52]]]],[11,R[51],E,E,10,[[["self"]],[T]]],[11,R[55],E,E,10,[[["self"]],[T]]],[11,R[53],E,E,10,[[["self"]],[R[56]]]],[11,"from",E,E,11,[[[T]],[T]]],[11,"into",E,E,11,[[],[U]]],[11,R[47],E,E,11,[[["self"]],[T]]],[11,R[48],E,E,11,[[[T],["self"]]]],[11,R[49],E,E,11,[[[U]],[R[52]]]],[11,R[50],E,E,11,[[],[R[52]]]],[11,R[51],E,E,11,[[["self"]],[T]]],[11,R[55],E,E,11,[[["self"]],[T]]],[11,R[53],E,E,11,[[["self"]],[R[56]]]],[11,"from",E,E,12,[[[T]],[T]]],[11,"into",E,E,12,[[],[U]]],[11,R[47],E,E,12,[[["self"]],[T]]],[11,R[48],E,E,12,[[[T],["self"]]]],[11,R[49],E,E,12,[[[U]],[R[52]]]],[11,R[50],E,E,12,[[],[R[52]]]],[11,R[51],E,E,12,[[["self"]],[T]]],[11,R[55],E,E,12,[[["self"]],[T]]],[11,R[53],E,E,12,[[["self"]],[R[56]]]],[11,"from",E,E,13,[[[T]],[T]]],[11,"into",E,E,13,[[],[U]]],[11,R[47],E,E,13,[[["self"]],[T]]],[11,R[48],E,E,13,[[[T],["self"]]]],[11,R[49],E,E,13,[[[U]],[R[52]]]],[11,R[50],E,E,13,[[],[R[52]]]],[11,R[51],E,E,13,[[["self"]],[T]]],[11,R[55],E,E,13,[[["self"]],[T]]],[11,R[53],E,E,13,[[["self"]],[R[56]]]],[11,"from",E,E,14,[[[T]],[T]]],[11,"into",E,E,14,[[],[U]]],[11,R[47],E,E,14,[[["self"]],[T]]],[11,R[48],E,E,14,[[[T],["self"]]]],[11,R[49],E,E,14,[[[U]],[R[52]]]],[11,R[50],E,E,14,[[],[R[52]]]],[11,R[51],E,E,14,[[["self"]],[T]]],[11,R[55],E,E,14,[[["self"]],[T]]],[11,R[53],E,E,14,[[["self"]],[R[56]]]],[11,"from",E,E,15,[[[T]],[T]]],[11,"into",E,E,15,[[],[U]]],[11,R[47],E,E,15,[[["self"]],[T]]],[11,R[48],E,E,15,[[[T],["self"]]]],[11,R[49],E,E,15,[[[U]],[R[52]]]],[11,R[50],E,E,15,[[],[R[52]]]],[11,R[51],E,E,15,[[["self"]],[T]]],[11,R[55],E,E,15,[[["self"]],[T]]],[11,R[53],E,E,15,[[["self"]],[R[56]]]],[11,"from",E,E,16,[[[T]],[T]]],[11,"into",E,E,16,[[],[U]]],[11,R[47],E,E,16,[[["self"]],[T]]],[11,R[48],E,E,16,[[[T],["self"]]]],[11,R[49],E,E,16,[[[U]],[R[52]]]],[11,R[50],E,E,16,[[],[R[52]]]],[11,R[51],E,E,16,[[["self"]],[T]]],[11,R[55],E,E,16,[[["self"]],[T]]],[11,R[53],E,E,16,[[["self"]],[R[56]]]],[11,"from",E,E,17,[[[T]],[T]]],[11,"into",E,E,17,[[],[U]]],[11,R[47],E,E,17,[[["self"]],[T]]],[11,R[48],E,E,17,[[[T],["self"]]]],[11,R[49],E,E,17,[[[U]],[R[52]]]],[11,R[50],E,E,17,[[],[R[52]]]],[11,R[51],E,E,17,[[["self"]],[T]]],[11,R[55],E,E,17,[[["self"]],[T]]],[11,R[53],E,E,17,[[["self"]],[R[56]]]],[11,"from",E,E,18,[[[T]],[T]]],[11,"into",E,E,18,[[],[U]]],[11,R[47],E,E,18,[[["self"]],[T]]],[11,R[48],E,E,18,[[[T],["self"]]]],[11,R[49],E,E,18,[[[U]],[R[52]]]],[11,R[50],E,E,18,[[],[R[52]]]],[11,R[51],E,E,18,[[["self"]],[T]]],[11,R[55],E,E,18,[[["self"]],[T]]],[11,R[53],E,E,18,[[["self"]],[R[56]]]],[11,"from",E,E,19,[[[T]],[T]]],[11,"into",E,E,19,[[],[U]]],[11,R[47],E,E,19,[[["self"]],[T]]],[11,R[48],E,E,19,[[[T],["self"]]]],[11,R[49],E,E,19,[[[U]],[R[52]]]],[11,R[50],E,E,19,[[],[R[52]]]],[11,R[51],E,E,19,[[["self"]],[T]]],[11,R[55],E,E,19,[[["self"]],[T]]],[11,R[53],E,E,19,[[["self"]],[R[56]]]],[11,"from",E,E,20,[[[T]],[T]]],[11,"into",E,E,20,[[],[U]]],[11,R[47],E,E,20,[[["self"]],[T]]],[11,R[48],E,E,20,[[[T],["self"]]]],[11,R[49],E,E,20,[[[U]],[R[52]]]],[11,R[50],E,E,20,[[],[R[52]]]],[11,R[51],E,E,20,[[["self"]],[T]]],[11,R[55],E,E,20,[[["self"]],[T]]],[11,R[53],E,E,20,[[["self"]],[R[56]]]],[11,"from",E,E,21,[[[T]],[T]]],[11,"into",E,E,21,[[],[U]]],[11,R[47],E,E,21,[[["self"]],[T]]],[11,R[48],E,E,21,[[[T],["self"]]]],[11,R[49],E,E,21,[[[U]],[R[52]]]],[11,R[50],E,E,21,[[],[R[52]]]],[11,R[51],E,E,21,[[["self"]],[T]]],[11,R[55],E,E,21,[[["self"]],[T]]],[11,R[53],E,E,21,[[["self"]],[R[56]]]],[11,"from",E,E,22,[[[T]],[T]]],[11,"into",E,E,22,[[],[U]]],[11,R[47],E,E,22,[[["self"]],[T]]],[11,R[48],E,E,22,[[[T],["self"]]]],[11,R[49],E,E,22,[[[U]],[R[52]]]],[11,R[50],E,E,22,[[],[R[52]]]],[11,R[51],E,E,22,[[["self"]],[T]]],[11,R[55],E,E,22,[[["self"]],[T]]],[11,R[53],E,E,22,[[["self"]],[R[56]]]],[11,"from",E,E,23,[[[T]],[T]]],[11,"into",E,E,23,[[],[U]]],[11,R[47],E,E,23,[[["self"]],[T]]],[11,R[48],E,E,23,[[[T],["self"]]]],[11,R[49],E,E,23,[[[U]],[R[52]]]],[11,R[50],E,E,23,[[],[R[52]]]],[11,R[51],E,E,23,[[["self"]],[T]]],[11,R[55],E,E,23,[[["self"]],[T]]],[11,R[53],E,E,23,[[["self"]],[R[56]]]],[11,"from",E,E,24,[[[T]],[T]]],[11,"into",E,E,24,[[],[U]]],[11,R[47],E,E,24,[[["self"]],[T]]],[11,R[48],E,E,24,[[[T],["self"]]]],[11,R[49],E,E,24,[[[U]],[R[52]]]],[11,R[50],E,E,24,[[],[R[52]]]],[11,R[51],E,E,24,[[["self"]],[T]]],[11,R[55],E,E,24,[[["self"]],[T]]],[11,R[53],E,E,24,[[["self"]],[R[56]]]],[11,"convert",E,E,25,[[["self"]],["array"]]],[11,"set",E,E,25,[[["bool"],["u32"],[R[34],["bool"]],["self"],[R[41]]]]],[11,"set",E,E,29,[[["bool"],["u32"],[R[34],["bool"]],["self"],[R[41]]]]],[11,"default",E,E,26,[[],["self"]]],[11,"default",E,E,29,[[],["self"]]],[11,"clone",E,E,25,[[["self"]],["self"]]],[11,"clone",E,E,0,[[["self"]],[R[57]]]],[11,"clone",E,E,1,[[["self"]],[R[16]]]],[11,"clone",E,E,2,[[["self"]],["dtype"]]],[11,"clone",E,E,3,[[["self"]],[R[21]]]],[11,"clone",E,E,4,[[["self"]],[R[22]]]],[11,"clone",E,E,5,[[["self"]],[R[58]]]],[11,"clone",E,E,6,[[["self"]],[R[27]]]],[11,"clone",E,E,7,[[["self"]],[R[28]]]],[11,"clone",E,E,8,[[["self"]],[R[32]]]],[11,"clone",E,E,9,[[["self"]],[R[59]]]],[11,"clone",E,E,10,[[["self"]],[R[24]]]],[11,"clone",E,E,11,[[["self"]],[R[60]]]],[11,"clone",E,E,12,[[["self"]],[R[61]]]],[11,"clone",E,E,13,[[["self"]],["yccstd"]]],[11,"clone",E,E,14,[[["self"]],[R[62]]]],[11,"clone",E,E,15,[[["self"]],[R[35]]]],[11,"clone",E,E,16,[[["self"]],[R[23]]]],[11,"clone",E,E,17,[[["self"]],[R[30]]]],[11,"clone",E,E,18,[[["self"]],[R[15]]]],[11,"clone",E,E,19,[[["self"]],[R[36]]]],[11,"clone",E,E,20,[[["self"]],["scalar"]]],[11,"clone",E,E,21,[[["self"]],[R[63]]]],[11,"clone",E,E,22,[[["self"]],[R[64]]]],[11,"clone",E,E,23,[[["self"]],["fluxfn"]]],[11,"clone",E,E,24,[[["self"]],["topkfn"]]],[11,"clone",E,E,26,[[["self"]],["dim4"]]],[11,"clone",E,E,29,[[["self"]],["seq"]]],[11,"clone",E,E,30,[[["self"]],["window"]]],[11,"clone",E,E,31,[[["self"]],["self"]]],[11,"clone",E,E,32,[[["self"]],["self"]]],[11,"from",E,E,30,[[["u64"]],["self"]]],[11,"from",E,E,31,[[["i64"]],["self"]]],[11,"from",E,E,0,[[["i32"]],["self"]]],[11,"from",E,E,2,[[["u32"]],["self"]]],[11,"from",E,E,3,[[["u32"]],["self"]]],[11,"from",E,E,6,[[["u32"]],["self"]]],[11,"from",E,E,7,[[["u32"]],["self"]]],[11,"from",E,E,8,[[["u32"]],["self"]]],[11,"from",E,E,12,[[["u32"]],["self"]]],[11,"from",E,E,17,[[["u32"]],["self"]]],[11,"from",E,E,18,[[["u32"]],["self"]]],[11,"from",E,E,19,[[["u32"]],["self"]]],[11,"drop",E,E,25,[[["self"]]]],[11,"drop",E,E,28,[[["self"]]]],[11,"drop",E,E,30,[[["self"]]]],[11,"drop",E,E,31,[[["self"]]]],[11,"drop",E,E,32,[[["self"]]]],[11,"eq",E,E,0,[[["self"],[R[57]]],["bool"]]],[11,"eq",E,E,1,[[[R[16]],["self"]],["bool"]]],[11,"eq",E,E,2,[[["dtype"],["self"]],["bool"]]],[11,"eq",E,E,3,[[["self"],[R[21]]],["bool"]]],[11,"eq",E,E,4,[[["self"],[R[22]]],["bool"]]],[11,"eq",E,E,5,[[["self"],[R[58]]],["bool"]]],[11,"eq",E,E,6,[[[R[27]],["self"]],["bool"]]],[11,"eq",E,E,7,[[["self"],[R[28]]],["bool"]]],[11,"eq",E,E,8,[[["self"],[R[32]]],["bool"]]],[11,"eq",E,E,9,[[["self"],[R[59]]],["bool"]]],[11,"eq",E,E,10,[[["self"],[R[24]]],["bool"]]],[11,"eq",E,E,11,[[[R[60]],["self"]],["bool"]]],[11,"eq",E,E,12,[[["self"],[R[61]]],["bool"]]],[11,"eq",E,E,13,[[["yccstd"],["self"]],["bool"]]],[11,"eq",E,E,14,[[["self"],[R[62]]],["bool"]]],[11,"eq",E,E,15,[[["self"],[R[35]]],["bool"]]],[11,"eq",E,E,16,[[["self"],[R[23]]],["bool"]]],[11,"eq",E,E,17,[[["self"],[R[30]]],["bool"]]],[11,"eq",E,E,18,[[["self"],[R[15]]],["bool"]]],[11,"eq",E,E,19,[[["self"],[R[36]]],["bool"]]],[11,"eq",E,E,20,[[["self"],["scalar"]],["bool"]]],[11,"ne",E,E,20,[[["self"],["scalar"]],["bool"]]],[11,"eq",E,E,21,[[[R[63]],["self"]],["bool"]]],[11,"eq",E,E,22,[[["self"],[R[64]]],["bool"]]],[11,"eq",E,E,23,[[["self"],["fluxfn"]],["bool"]]],[11,"eq",E,E,24,[[["self"],["topkfn"]],["bool"]]],[11,"eq",E,E,26,[[["self"],["dim4"]],["bool"]]],[11,"ne",E,E,26,[[["self"],["dim4"]],["bool"]]],[11,"fmt",E,E,0,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,1,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,2,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,3,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,4,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,5,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,6,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,7,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,8,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,9,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,10,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,11,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,12,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,13,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,14,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,15,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,16,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,17,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,18,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,19,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,20,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,21,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,22,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,23,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,24,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,26,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,1,[[["self"],[R[65]]],[[R[52],[R[66]]],[R[66]]]]],[11,"fmt",E,E,0,[[["self"],[R[65]]],[[R[52],[R[66]]],[R[66]]]]],[11,"fmt",E,E,26,[[["self"],[R[65]]],[R[52]]]],[11,"fmt",E,E,29,[[["self"],[R[65]]],[R[52]]]],[11,"add",E,E,25,[[["f64"],[R[29],["f64"]]]]],[11,"add",E,E,25,[[["f32"],[R[29],["f32"]]]]],[11,"add",E,E,25,[[["f64"]]]],[11,"add",E,E,25,[[["f32"]]]],[11,"add",E,E,25,[[["u64"]]]],[11,"add",E,E,25,[[["i64"]]]],[11,"add",E,E,25,[[["u32"]]]],[11,"add",E,E,25,[[["i32"]]]],[11,"add",E,E,25,[[["u8"]]]],[11,"add",E,E,25,[[["array"]]]],[11,"add",E,E,25,[[["array"]]]],[11,"sub",E,E,25,[[["f64"],[R[29],["f64"]]]]],[11,"sub",E,E,25,[[["f32"],[R[29],["f32"]]]]],[11,"sub",E,E,25,[[["f64"]]]],[11,"sub",E,E,25,[[["f32"]]]],[11,"sub",E,E,25,[[["u64"]]]],[11,"sub",E,E,25,[[["i64"]]]],[11,"sub",E,E,25,[[["u32"]]]],[11,"sub",E,E,25,[[["i32"]]]],[11,"sub",E,E,25,[[["u8"]]]],[11,"sub",E,E,25,[[["array"]]]],[11,"sub",E,E,25,[[["array"]]]],[11,"mul",E,E,25,[[["f64"],[R[29],["f64"]]]]],[11,"mul",E,E,25,[[["f32"],[R[29],["f32"]]]]],[11,"mul",E,E,25,[[["f64"]]]],[11,"mul",E,E,25,[[["f32"]]]],[11,"mul",E,E,25,[[["u64"]]]],[11,"mul",E,E,25,[[["i64"]]]],[11,"mul",E,E,25,[[["u32"]]]],[11,"mul",E,E,25,[[["i32"]]]],[11,"mul",E,E,25,[[["u8"]]]],[11,"mul",E,E,25,[[["array"]]]],[11,"mul",E,E,25,[[["array"]]]],[11,"div",E,E,25,[[["f64"],[R[29],["f64"]]]]],[11,"div",E,E,25,[[["f32"],[R[29],["f32"]]]]],[11,"div",E,E,25,[[["f64"]]]],[11,"div",E,E,25,[[["f32"]]]],[11,"div",E,E,25,[[["u64"]]]],[11,"div",E,E,25,[[["i64"]]]],[11,"div",E,E,25,[[["u32"]]]],[11,"div",E,E,25,[[["i32"]]]],[11,"div",E,E,25,[[["u8"]]]],[11,"div",E,E,25,[[["array"]]]],[11,"div",E,E,25,[[["array"]]]],[11,"rem",E,E,25,[[["array"]]]],[11,"rem",E,E,25,[[["array"]]]],[11,"neg",E,E,25,[[]]],[11,"add_assign",E,E,25,[[["self"],["array"]]]],[11,"sub_assign",E,E,25,[[["self"],["array"]]]],[11,"mul_assign",E,E,25,[[["self"],["array"]]]],[11,"div_assign",E,E,25,[[["self"],["array"]]]],[11,"rem_assign",E,E,25,[[["self"],["array"]]]],[11,"bitand",E,E,25,[[["array"]]]],[11,"bitand",E,E,25,[[["array"]]]],[11,"bitor",E,E,25,[[["array"]]]],[11,"bitor",E,E,25,[[["array"]]]],[11,"bitxor",E,E,25,[[["array"]]]],[11,"bitxor",E,E,25,[[["array"]]]],[11,"shl",E,E,25,[[["array"]]]],[11,"shl",E,E,25,[[["array"]]]],[11,"shr",E,E,25,[[["array"]]]],[11,"shr",E,E,25,[[["array"]]]],[11,"bitand_assign",E,E,25,[[["self"],["array"]]]],[11,"bitor_assign",E,E,25,[[["self"],["array"]]]],[11,"bitxor_assign",E,E,25,[[["self"],["array"]]]],[11,"shl_assign",E,E,25,[[["self"],["array"]]]],[11,"shr_assign",E,E,25,[[["self"],["array"]]]],[11,"index",E,E,26,[[["usize"],["self"]],["u64"]]],[11,"description",E,E,0,[[["self"]],["str"]]],[11,R[67],E,R[68],38,[[],["bool"]]],[11,R[43],E,R[69],38,[[],["bool"]]]],"p":[[4,"AfError"],[4,"Backend"],[4,"DType"],[4,R[70]],[4,R[71]],[4,R[72]],[4,R[73]],[4,R[74]],[4,R[75]],[4,R[76]],[4,"MatProp"],[4,R[77]],[4,R[78]],[4,"YCCStd"],[4,R[79]],[4,R[80]],[4,R[81]],[4,R[82]],[4,R[83]],[4,R[84]],[4,"Scalar"],[4,R[85]],[4,R[86]],[4,"FluxFn"],[4,"TopkFn"],[3,"Array"],[3,"Dim4"],[3,R[87]],[3,"Indexer"],[3,"Seq"],[3,"Window"],[3,R[88]],[3,R[89]],[8,R[90]],[8,R[91]],[8,R[92]],[8,R[93]],[8,R[94]],[8,R[95]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);