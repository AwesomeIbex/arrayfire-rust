var N = null;var searchIndex = {};
searchIndex["arrayfire"]={"doc":"ArrayFire is a high performance software library for parallel computing with an easy-to-use API. ArrayFire abstracts away much of the details of programming parallel architectures by providing a high-level container object, the Array, that represents data stored on a CPU, GPU, FPGA, or other type of accelerator. This abstraction permits developers to write massively parallel applications in a high-level language where they need not be concerned about low-level optimizations that are frequently required to achieve high throughput on most parallel architectures. This crate provides Rust bindings for the ArrayFire library. Given below table shows the rust bindings compatability with ArrayFire upstream.  If you find any bugs, please report them on github.","items":[[3,"Array","arrayfire","A multidimensional data container",N,N],[3,"Dim4","","Dim4 is used to store Array dimensions",N,N],[3,"Callback","","Structure holding handle to callback function",N,N],[3,"Indexer","","Struct to manage an array of resources of type `af_indexer_t`(ArrayFire C struct)",N,N],[3,"Seq","","Sequences are used for indexing Arrays",N,N],[3,"Window","","Used to render Array objects",N,N],[3,"RandomEngine","","Random number generator engine",N,N],[3,"Features","","A set of Array objects (usually, used in Computer vision context)",N,N],[4,"AfError","","Error codes",N,N],[13,"SUCCESS","","The function returned successfully",0,N],[13,"ERR_NO_MEM","","The system or device ran out of memory",0,N],[13,"ERR_DRIVER","","There was an error in the device driver",0,N],[13,"ERR_RUNTIME","","There was an error with the runtime environment",0,N],[13,"ERR_INVALID_ARRAY","","The input array is not a valid Array object",0,N],[13,"ERR_ARG","","One of the function arguments is incorrect",0,N],[13,"ERR_SIZE","","The size is incorrect",0,N],[13,"ERR_TYPE","","The type is not suppported by this function",0,N],[13,"ERR_DIFF_TYPE","","The type of the input arrays are not compatible",0,N],[13,"ERR_BATCH","","Function does not support GFOR / batch mode",0,N],[13,"ERR_DEVICE","","Input does not belong to the current device",0,N],[13,"ERR_NOT_SUPPORTED","","The option is not supported",0,N],[13,"ERR_NOT_CONFIGURED","","This build of ArrayFire does not support this feature",0,N],[13,"ERR_NO_DBL","","This device does not support double",0,N],[13,"ERR_NO_GFX","","This build of ArrayFire was not built with graphics or this device does not support graphics",0,N],[13,"ERR_INTERNAL","","There was an internal error either in ArrayFire or in a project upstream",0,N],[13,"ERR_UNKNOWN","","Unknown Error",0,N],[4,"Backend","","Compute/Acceleration Backend",N,N],[13,"DEFAULT","","Default backend order: OpenCL -> CUDA -> CPU",1,N],[13,"CPU","","CPU a.k.a sequential algorithms",1,N],[13,"CUDA","","CUDA Compute Backend",1,N],[13,"OPENCL","","OpenCL Compute Backend",1,N],[4,"DType","","Types of Array data type",N,N],[13,"F32","","32 bit float",2,N],[13,"C32","","32 bit complex float",2,N],[13,"F64","","64 bit float",2,N],[13,"C64","","64 bit complex float",2,N],[13,"B8","","8 bit boolean",2,N],[13,"S32","","32 bit signed integer",2,N],[13,"U32","","32 bit unsigned integer",2,N],[13,"U8","","8 bit unsigned integer",2,N],[13,"S64","","64 bit signed integer",2,N],[13,"U64","","64 bit unsigned integer",2,N],[13,"S16","","16 bit signed integer",2,N],[13,"U16","","16 bit unsigned integer",2,N],[4,"InterpType","","Dictates the interpolation method to be used by a function",N,N],[13,"NEAREST","","Nearest Neighbor interpolation method",3,N],[13,"LINEAR","","Linear interpolation method",3,N],[13,"BILINEAR","","Bilinear interpolation method",3,N],[13,"CUBIC","","Cubic interpolation method",3,N],[13,"LOWER","","Floor indexed",3,N],[13,"LINEAR_COSINE","","Linear interpolation with cosine smoothing",3,N],[13,"BILINEAR_COSINE","","Bilinear interpolation with cosine smoothing",3,N],[13,"BICUBIC","","Bicubic interpolation",3,N],[13,"CUBIC_SPLINE","","Cubic interpolation with Catmull-Rom splines",3,N],[13,"BICUBIC_SPLINE","","Bicubic interpolation with Catmull-Rom splines",3,N],[4,"BorderType","","Helps determine how to pad kernels along borders",N,N],[13,"ZERO","","Pad using zeros",4,N],[13,"SYMMETRIC","","Pad using mirrored values along border",4,N],[4,"Connectivity","","Used by `regions` function to identify type of connectivity",N,N],[13,"FOUR","","North-East-South-West (N-E-S-W) connectivity from given pixel/point",5,N],[13,"EIGHT","","N-NE-E-SE-S-SW-W-NW connectivity from given pixel/point",5,N],[4,"ConvMode","","Helps determine the size of output of convolution",N,N],[13,"DEFAULT","","Default convolution mode where output size is same as input size",6,N],[13,"EXPAND","","Output of convolution is expanded based on signal and filter sizes",6,N],[4,"ConvDomain","","Helps determine if convolution is in Spatial or Frequency domain",N,N],[13,"AUTO","","ArrayFire chooses whether the convolution will be in spatial domain or frequency domain",7,N],[13,"SPATIAL","","Convoltion in spatial domain",7,N],[13,"FREQUENCY","","Convolution in frequency domain",7,N],[4,"MatchType","","Error metric used by `matchTemplate` function",N,N],[13,"SAD","","Sum of Absolute Differences",8,N],[13,"ZSAD","","Zero-mean Sum of Absolute Differences",8,N],[13,"LSAD","","Locally scaled Sum of Absolute Differences",8,N],[13,"SSD","","Sum of Squared Differences",8,N],[13,"ZSSD","","Zero-mean Sum of Squared Differences",8,N],[13,"LSSD","","Localy scaled Sum of Squared Differences",8,N],[13,"NCC","","Normalized Cross Correlation",8,N],[13,"ZNCC","","Zero-mean Normalized Cross Correlation",8,N],[13,"SHD","","Sum of Hamming Distances",8,N],[4,"ColorSpace","","Identify the color space of given image(Array)",N,N],[13,"GRAY","","Grayscale color space",9,N],[13,"RGB","","Red-Green-Blue color space",9,N],[13,"HSV","","Hue-Saturation-value color space",9,N],[4,"MatProp","","Helps determine the type of a Matrix",N,N],[13,"NONE","","Default (no-op)",10,N],[13,"TRANS","","Data needs to be transposed",10,N],[13,"CTRANS","","Data needs to be conjugate transposed",10,N],[13,"UPPER","","Matrix is upper triangular",10,N],[13,"LOWER","","Matrix is lower triangular",10,N],[13,"DIAGUNIT","","Matrix diagonal has unitary values",10,N],[13,"SYM","","Matrix is symmetric",10,N],[13,"POSDEF","","Matrix is positive definite",10,N],[13,"ORTHOG","","Matrix is orthogonal",10,N],[13,"TRIDIAG","","Matrix is tri-diagonal",10,N],[13,"BLOCKDIAG","","Matrix is block-diagonal",10,N],[4,"NormType","","Norm type",N,N],[13,"VECTOR_1","","Treats input as a vector and return sum of absolute values",11,N],[13,"VECTOR_INF","","Treats input as vector and return max of absolute values",11,N],[13,"VECTOR_2","","Treats input as vector and returns euclidean norm",11,N],[13,"VECTOR_P","","Treats input as vector and returns the p-norm",11,N],[13,"MATRIX_1","","Return the max of column sums",11,N],[13,"MATRIX_INF","","Return the max of row sums",11,N],[13,"MATRIX_2","","Returns the max singular value (Currently not supported)",11,N],[13,"MATRIX_L_PQ","","Returns Lpq-norm",11,N],[4,"ColorMap","","Dictates what color map is used for Image rendering",N,N],[13,"DEFAULT","","Default color map is grayscale range [0-1]",12,N],[13,"SPECTRUM","","Visible spectrum color map",12,N],[13,"COLORS","","Colors",12,N],[13,"RED","","Red hue map",12,N],[13,"MOOD","","Mood color map",12,N],[13,"HEAT","","Heat color map",12,N],[13,"BLUE","","Blue hue map",12,N],[4,"YCCStd","","YCbCr Standards",N,N],[13,"YCC_601","","ITU-R BT.601 (formerly CCIR 601) standard",13,N],[13,"YCC_709","","ITU-R BT.709 standard",13,N],[13,"YCC_2020","","ITU-R BT.2020 standard",13,N],[4,"HomographyType","","Homography type",N,N],[13,"RANSAC","","RANdom SAmple Consensus algorithm",14,N],[13,"LMEDS","","Least Median of Squares",14,N],[4,"MarkerType","","Plotting markers",N,N],[13,"NONE","","No marker",15,N],[13,"POINT","","Pointer marker",15,N],[13,"CIRCLE","","Hollow circle marker",15,N],[13,"SQUARE","","Hollow Square marker",15,N],[13,"TRIANGLE","","Hollow Triangle marker",15,N],[13,"CROSS","","Cross-hair marker",15,N],[13,"PLUS","","Plus symbol marker",15,N],[13,"STAR","","Start symbol marker",15,N],[4,"MomentType","","Image moment types",N,N],[13,"M00","","Central moment of order (0 + 0)",16,N],[13,"M01","","Central moment of order (0 + 1)",16,N],[13,"M10","","Central moment of order (1 + 0)",16,N],[13,"M11","","Central moment of order (1 + 1)",16,N],[13,"FIRST_ORDER","","All central moments of order (0,0), (0,1), (1,0) and (1,1)",16,N],[4,"SparseFormat","","Sparse storage format type",N,N],[13,"DENSE","","Dense format",17,N],[13,"CSR","","Compressed sparse row format",17,N],[13,"CSC","","Compressed sparse coloumn format",17,N],[13,"COO","","Coordinate list (row, coloumn, value) tuples.",17,N],[4,"BinaryOp","","Binary operation types for generalized scan functions",N,N],[13,"ADD","","Addition operation",18,N],[13,"MUL","","Multiplication operation",18,N],[13,"MIN","","Minimum operation",18,N],[13,"MAX","","Maximum operation",18,N],[4,"RandomEngineType","","Random engine types",N,N],[13,"PHILOX_4X32_10","","Philox variant with N=4, W=32 and Rounds=10",19,N],[13,"THREEFRY_2X32_16","","Threefry variant with N=2, W=32 and Rounds=16",19,N],[13,"MERSENNE_GP11213","","Mersenne variant with MEXP = 11213",19,N],[4,"Scalar","","Scalar value types",N,N],[13,"F32","","32 bit float",20,N],[13,"C32","","32 bit complex float",20,N],[13,"F64","","64 bit float",20,N],[13,"C64","","64 bit complex float",20,N],[13,"B8","","8 bit boolean",20,N],[13,"S32","","32 bit signed integer",20,N],[13,"U32","","32 bit unsigned integer",20,N],[13,"U8","","8 bit unsigned integer",20,N],[13,"S64","","64 bit signed integer",20,N],[13,"U64","","64 bit unsigned integer",20,N],[13,"S16","","16 bit signed integer",20,N],[13,"U16","","16 bit unsigned integer",20,N],[4,"CannyThresholdType","","Canny edge detector threshold operations types",N,N],[13,"MANUAL","","User has to define canny thresholds manually",21,N],[13,"OTSU","","Determine canny algorithm high threshold using Otsu algorithm automatically",21,N],[4,"DiffusionEq","","Anisotropic diffusion flux equation types",N,N],[13,"QUADRATIC","","Quadratic flux function",22,N],[13,"EXPONENTIAL","","Exponential flux function",22,N],[13,"DEFAULT","","Default flux function, a.k.a exponential",22,N],[4,"FluxFn","","Diffusion equation types",N,N],[13,"GRADIENT","","Quadratic flux function",23,N],[13,"MCDE","","Modified curvature diffusion equation",23,N],[13,"DEFAULT","","Default diffusion method, Gradient",23,N],[4,"TopkFn","","topk function ordering",N,N],[13,"MIN","","Top k min values",24,N],[13,"MAX","","Top k max values",24,N],[13,"DEFAULT","","Default option(max)",24,N],[5,"print","","Print data in the Array",N,[[["array"]]]],[5,"print_gen","","Generalized Array print function",N,[[["string"],["array"],["option",["i32"]]]]],[5,"eval_multiple","","evaluate multiple arrays",N,[[["vec",["array"]]]]],[5,"set_manual_eval","","Set eval flag value",N,[[["bool"]]]],[5,"is_eval_manual","","Get eval flag value",N,[[],["bool"]]],[5,"sum","","Sum elements along a given dimension",N,[[["array"],["i32"]],["array"]]],[5,"product","","Compute product of elements along a given dimension",N,[[["array"],["i32"]],["array"]]],[5,"min","","Find minimum among elements of given dimension",N,[[["array"],["i32"]],["array"]]],[5,"max","","Find maximum among elements of given dimension",N,[[["array"],["i32"]],["array"]]],[5,"all_true","","Find if all of the values along a given dimension in the Array are true",N,[[["array"],["i32"]],["array",["bool"]]]],[5,"any_true","","Find if any of the values along a given dimension in the Array are true",N,[[["array"],["i32"]],["array",["bool"]]]],[5,"count","","Count number of non-zero elements along a given dimension",N,[[["array"],["i32"]],["array",["u32"]]]],[5,"accum","","Perform exclusive sum of elements along a given dimension",N,[[["array"],["i32"]],["array"]]],[5,"diff1","","Calculate first order numerical difference along a given dimension",N,[[["array"],["i32"]],["array"]]],[5,"diff2","","Calculate second order numerical difference along a given dimension",N,[[["array"],["i32"]],["array"]]],[5,"sum_nan","","Sum along specific dimension using user specified value instead of `NAN` values",N,[[["array"],["i32"],["f64"]],["array"]]],[5,"product_nan","","Product of elements along specific dimension using user specified value instead of `NAN` values",N,[[["array"],["i32"],["f64"]],["array"]]],[5,"sum_all","","Sum all values of the Array",N,N],[5,"product_all","","Product of all values of the Array",N,N],[5,"min_all","","Find minimum among all values of the Array",N,N],[5,"max_all","","Find maximum among all values of the Array",N,N],[5,"all_true_all","","Find if all values of Array are non-zero",N,N],[5,"any_true_all","","Find if any value of Array is non-zero",N,N],[5,"count_all","","Count number of non-zero values in the Array",N,N],[5,"sum_nan_all","","Sum all values using user provided value for `NAN`",N,N],[5,"product_nan_all","","Product of all values using user provided value for `NAN`",N,N],[5,"imin","","Find minimum value along given dimension and their corresponding indices",N,N],[5,"imax","","Find maximum value along given dimension and their corresponding indices",N,N],[5,"imin_all","","Find minimum and it's index in the whole Array",N,N],[5,"imax_all","","Find maximum and it's index in the whole Array",N,N],[5,"locate","","Locate the indices of non-zero elements.",N,[[["array"]],["array",["u32"]]]],[5,"sort","","Sort the values in input Arrays",N,[[["array"],["u32"],["bool"]],["array"]]],[5,"sort_index","","Sort the values in input Arrays",N,N],[5,"sort_by_key","","Sort the values in input Arrays",N,N],[5,"set_unique","","Find unique values from a Set",N,[[["array"],["bool"]],["array"]]],[5,"set_union","","Find union of two sets",N,[[["array"],["array"],["bool"]],["array"]]],[5,"set_intersect","","Find intersection of two sets",N,[[["array"],["array"],["bool"]],["array"]]],[5,"scan","","Generalized scan",N,[[["array"],["i32"],["binaryop"],["bool"]],["array"]]],[5,"scan_by_key","","Generalized scan by key",N,[[["array"],["array"],["i32"],["binaryop"],["bool"]],["array"]]],[5,"abs","","Computes absolute value",N,[[["array"]],["array"]]],[5,"arg","","Computes phase value",N,[[["array"]],["array"]]],[5,"trunc","","Truncate the values in an Array",N,[[["array"]],["array"]]],[5,"sign","","Computes the sign of input Array values",N,[[["array"]],["array"]]],[5,"round","","Round the values in an Array",N,[[["array"]],["array"]]],[5,"floor","","Floor the values in an Array",N,[[["array"]],["array"]]],[5,"ceil","","Ceil the values in an Array",N,[[["array"]],["array"]]],[5,"sigmoid","","Compute sigmoid function",N,[[["array"]],["array"]]],[5,"expm1","","Compute e raised to the power of value -1",N,[[["array"]],["array"]]],[5,"erf","","Compute error function value",N,[[["array"]],["array"]]],[5,"erfc","","Compute the complementary error function value",N,[[["array"]],["array"]]],[5,"log10","","Compute logarithm base 10",N,[[["array"]],["array"]]],[5,"log1p","","Compute the logarithm of input Array + 1",N,[[["array"]],["array"]]],[5,"log2","","Compute logarithm base 2",N,[[["array"]],["array"]]],[5,"cbrt","","Compute the cube root",N,[[["array"]],["array"]]],[5,"tgamma","","Compute gamma function",N,[[["array"]],["array"]]],[5,"lgamma","","Compute the logarithm of absolute values of gamma function",N,[[["array"]],["array"]]],[5,"acosh","","Compute acosh",N,[[["array"]],["array"]]],[5,"acos","","Compute acos",N,[[["array"]],["array"]]],[5,"asin","","Compute asin",N,[[["array"]],["array"]]],[5,"asinh","","Compute asinh",N,[[["array"]],["array"]]],[5,"atan","","Compute atan",N,[[["array"]],["array"]]],[5,"atanh","","Compute atanh",N,[[["array"]],["array"]]],[5,"cos","","Compute cos",N,[[["array"]],["array"]]],[5,"cosh","","Compute cosh",N,[[["array"]],["array"]]],[5,"exp","","Compute e raised to the power of value",N,[[["array"]],["array"]]],[5,"log","","Compute the natural logarithm",N,[[["array"]],["array"]]],[5,"sin","","Compute sin",N,[[["array"]],["array"]]],[5,"sinh","","Compute sinh",N,[[["array"]],["array"]]],[5,"sqrt","","Compute the square root",N,[[["array"]],["array"]]],[5,"tan","","Compute tan",N,[[["array"]],["array"]]],[5,"tanh","","Compute tanh",N,[[["array"]],["array"]]],[5,"real","","Extract real values from a complex Array",N,[[["array"]],["array"]]],[5,"imag","","Extract imaginary values from a complex Array",N,[[["array"]],["array"]]],[5,"cplx","","Create a complex Array from real Array",N,[[["array"]],["array"]]],[5,"conjg","","Compute the complex conjugate",N,[[["array"]],["array"]]],[5,"pow2","","Compute two raised to the power of value",N,[[["array"]],["array"]]],[5,"factorial","","Compute the factorial",N,[[["array"]],["array"]]],[5,"iszero","","Check if values are zero",N,[[["array"]],["array",["bool"]]]],[5,"isinf","","Check if values are infinity",N,[[["array"]],["array",["bool"]]]],[5,"isnan","","Check if values are NaN",N,[[["array"]],["array",["bool"]]]],[5,"bitand","","Elementwise AND(bit) operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"bitor","","Elementwise OR(bit) operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"bitxor","","Elementwise XOR(bit) operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"neq","","Elementwise not equals comparison of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"and","","Elementwise logical and operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"or","","Elementwise logical or operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"minof","","Elementwise minimum operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"maxof","","Elementwise maximum operation of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"hypot","","Compute length of hypotenuse of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"add","","Addition of two Arrays",N,[[["t"],["u"],["bool"]],["array"]]],[5,"sub","","Subtraction of two Arrays",N,[[["t"],["u"],["bool"]],["array"]]],[5,"mul","","Multiplication of two Arrays",N,[[["t"],["u"],["bool"]],["array"]]],[5,"div","","Division of two Arrays",N,[[["t"],["u"],["bool"]],["array"]]],[5,"rem","","Compute remainder from two Arrays",N,[[["t"],["u"],["bool"]],["array"]]],[5,"shiftl","","Compute left shift",N,[[["t"],["u"],["bool"]],["array"]]],[5,"shiftr","","Compute right shift",N,[[["t"],["u"],["bool"]],["array"]]],[5,"lt","","Perform `less than` comparison operation",N,[[["t"],["u"],["bool"]],["array"]]],[5,"gt","","Perform `greater than` comparison operation",N,[[["t"],["u"],["bool"]],["array"]]],[5,"le","","Perform `less than equals` comparison operation",N,[[["t"],["u"],["bool"]],["array"]]],[5,"ge","","Perform `greater than equals` comparison operation",N,[[["t"],["u"],["bool"]],["array"]]],[5,"eq","","Perform `equals` comparison operation",N,[[["t"],["u"],["bool"]],["array"]]],[5,"modulo","","Compute modulo of two Arrays",N,[[["t"],["u"],["bool"]],["array"]]],[5,"atan2","","Calculate atan2 of two Arrays",N,[[["t"],["u"],["bool"]],["array"]]],[5,"cplx2","","Create complex array from two Arrays",N,[[["t"],["u"],["bool"]],["array"]]],[5,"root","","Compute root",N,[[["t"],["u"],["bool"]],["array"]]],[5,"pow","","Computer power",N,[[["t"],["u"],["bool"]],["array"]]],[5,"clamp","","Clamp the values of Array",N,[[["array"],["c"],["c"],["bool"]],["array"]]],[5,"set_backend","","Toggle backends between cuda, opencl or cpu",N,[[["backend"]]]],[5,"get_backend_count","","Get the available backend count",N,[[],["u32"]]],[5,"get_available_backends","","Get the available backends",N,[[],["vec",["backend"]]]],[5,"get_active_backend","","Get current active backend",N,[[],["backend"]]],[5,"matmul","","Matrix multiple of two Arrays",N,[[["array"],["array"],["matprop"],["matprop"]],["array"]]],[5,"dot","","Calculate the dot product of vectors.",N,[[["array"],["array"],["matprop"],["matprop"]],["array"]]],[5,"transpose","","Transpose of a matrix.",N,[[["array"],["bool"]],["array"]]],[5,"transpose_inplace","","Inplace transpose of a matrix.",N,[[["array"],["bool"]]]],[5,"constant","","Create an Array with constant value",N,[[["g"],["dim4"]],["array"]]],[5,"range","","Create a Range of values",N,[[["dim4"],["i32"]],["array"]]],[5,"iota","","Create a range of values",N,[[["dim4"],["dim4"]],["array"]]],[5,"identity","","Create an identity array with 1's in diagonal",N,[[["dim4"]],["array"]]],[5,"diag_create","","Create a diagonal matrix",N,[[["array"],["i32"]],["array"]]],[5,"diag_extract","","Extract diagonal from a given Matrix",N,[[["array"],["i32"]],["array"]]],[5,"join","","Join two arrays",N,[[["i32"],["array"],["array"]],["array"]]],[5,"join_many","","Join multiple arrays",N,[[["i32"],["vec",["array"]]],["array"]]],[5,"tile","","Tile the input array along specified dimension",N,[[["array"],["dim4"]],["array"]]],[5,"reorder","","Reorder the array in specified order",N,[[["array"],["dim4"]],["array"]]],[5,"shift","","\"Circular shift of values along specified dimension",N,N],[5,"moddims","","Change the shape of the Array",N,[[["array"],["dim4"]],["array"]]],[5,"flat","","Flatten the multidimensional Array to an 1D Array",N,[[["array"]],["array"]]],[5,"flip","","Flip the Array",N,[[["array"],["u32"]],["array"]]],[5,"lower","","Create lower triangular matrix",N,[[["array"],["bool"]],["array"]]],[5,"upper","","Create upper triangular matrix",N,[[["array"],["bool"]],["array"]]],[5,"select","","Element wise conditional operator for Arrays",N,[[["array"],["array"],["array"]],["array"]]],[5,"selectl","","Element wise conditional operator for Arrays",N,[[["f64"],["array"],["array"]],["array"]]],[5,"selectr","","Element wise conditional operator for Arrays",N,[[["array"],["array"],["f64"]],["array"]]],[5,"replace","","Inplace replace in Array based on a condition",N,[[["array"],["array"],["array"]]]],[5,"replace_scalar","","Inplace replace in Array based on a condition",N,[[["array"],["array"],["f64"]]]],[5,"get_version","","Get ArrayFire Version Number",N,N],[5,"get_revision","","Get ArrayFire Revision (commit) information of the library.",N,[[],["cow",["str"]]]],[5,"info","","Print library meta-info",N,[[]]],[5,"info_string","","Return library meta-info as `String`",N,[[["bool"]],["string"]]],[5,"device_info","","Gets the information about device and platform as strings.",N,N],[5,"init","","Initialize ArrayFire library",N,[[]]],[5,"device_count","","Get total number of available devices",N,[[],["i32"]]],[5,"is_double_available","","Check if a device has double support",N,[[["i32"]],["bool"]]],[5,"set_device","","Set active device",N,[[["i32"]]]],[5,"get_device","","Get the current active device id",N,[[],["i32"]]],[5,"device_mem_info","","Get memory information from the memory manager for the current active device",N,N],[5,"print_mem_info","","Print buffer details from the ArrayFire device manager",N,[[["string"],["i32"]]]],[5,"set_mem_step_size","","Set the minimum memory chunk size",N,[[["usize"]]]],[5,"get_mem_step_size","","Get the minimum memory chunk size",N,[[],["usize"]]],[5,"device_gc","","Call the garbage collection routine",N,[[]]],[5,"sync","","Sync all operations on given device",N,[[["i32"]]]],[5,"register_error_handler","","Register user provided error handler",N,[[["callback"]]]],[5,"handle_error_general","","Default error handling callback provided by ArrayFire crate",N,[[["aferror"]]]],[5,"index","","Indexes the `input` Array using `seqs` Sequences",N,N],[5,"row","","Extract `row_num` row from `input` Array",N,[[["array"],["u64"]],["array"]]],[5,"set_row","","Set `row_num`^th row in `input` Array to a new Array `new_row`",N,[[["array"],["array"],["u64"]],["array"]]],[5,"rows","","Get an Array with all rows from `first` to `last` in the `input` Array",N,[[["array"],["u64"],["u64"]],["array"]]],[5,"set_rows","","Set rows from `first` to `last` in `input` Array with rows from Array `new_rows`",N,[[["array"],["array"],["u64"],["u64"]],["array"]]],[5,"col","","Extract `col_num` col from `input` Array",N,[[["array"],["u64"]],["array"]]],[5,"set_col","","Set `col_num`^th col in `input` Array to a new Array `new_col`",N,[[["array"],["array"],["u64"]],["array"]]],[5,"cols","","Get all cols from `first` to `last` in the `input` Array",N,[[["array"],["u64"],["u64"]],["array"]]],[5,"set_cols","","Set cols from `first` to `last` in `input` Array with cols from Array `new_cols`",N,[[["array"],["array"],["u64"],["u64"]],["array"]]],[5,"slice","","Get `slice_num`^th slice from `input` Array",N,[[["array"],["u64"]],["array"]]],[5,"set_slice","","Set slice `slice_num` in `input` Array to a new Array `new_slice`",N,[[["array"],["array"],["u64"]],["array"]]],[5,"slices","","Get slices from `first` to `last` in `input` Array",N,[[["array"],["u64"],["u64"]],["array"]]],[5,"set_slices","","Set `first` to `last` slices of `input` Array to a new Array `new_slices`",N,[[["array"],["array"],["u64"],["u64"]],["array"]]],[5,"lookup","","Lookup(hash) an Array using another Array",N,[[["array"],["array"],["i32"]],["array"]]],[5,"assign_seq","","Assign(copy) content of an Array to another Array indexed by Sequences",N,N],[5,"index_gen","","Index an Array using any combination of Array's and Sequence's",N,[[["array"],["indexer"]],["array"]]],[5,"assign_gen","","Assign an Array to another after indexing it using any combination of Array's and Sequence's",N,[[["array"],["indexer"],["array"]],["array"]]],[5,"gradient","","Calculate the gradients",N,N],[5,"load_image","","Load Image into Array",N,[[["string"],["bool"]],["array"]]],[5,"load_image_native","","Load Image into Array in it's native type",N,[[["string"]],["array"]]],[5,"save_image","","Save an Array to an image file",N,[[["string"],["array"]]]],[5,"save_image_native","","Save an Array without modifications to an image file",N,[[["string"],["array"]]]],[5,"resize","","Resize an Image",N,[[["array"],["i64"],["i64"],["interptype"]],["array"]]],[5,"transform","","Transform(Affine) an Image",N,[[["array"],["array"],["i64"],["i64"],["interptype"],["bool"]],["array"]]],[5,"rotate","","Rotate an Image",N,[[["array"],["f64"],["bool"],["interptype"]],["array"]]],[5,"translate","","Translate an Image",N,[[["array"],["f32"],["f32"],["i64"],["i64"],["interptype"]],["array"]]],[5,"scale","","Scale an Image",N,[[["array"],["f32"],["f32"],["i64"],["i64"],["interptype"]],["array"]]],[5,"skew","","Skew an image",N,[[["array"],["f32"],["f32"],["i64"],["i64"],["interptype"],["bool"]],["array"]]],[5,"histogram","","Compute Histogram of an Array",N,[[["array"],["u32"],["f64"],["f64"]],["array",["u32"]]]],[5,"dilate","","Dilate an Image",N,[[["array"],["array"]],["array"]]],[5,"erode","","Erode an Image",N,[[["array"],["array"]],["array"]]],[5,"dilate3","","Dilate a Volume",N,[[["array"],["array"]],["array"]]],[5,"erode3","","Erode a Volume",N,[[["array"],["array"]],["array"]]],[5,"bilateral","","Bilateral Filter.",N,[[["array"],["f32"],["f32"],["bool"]],["array"]]],[5,"mean_shift","","Meanshift Filter.",N,[[["array"],["f32"],["f32"],["u32"],["bool"]],["array"]]],[5,"medfilt","","Median filter",N,[[["array"],["u64"],["u64"],["bordertype"]],["array"]]],[5,"minfilt","","Box filter with minimum as box operation",N,[[["array"],["u64"],["u64"],["bordertype"]],["array"]]],[5,"maxfilt","","Box filter with maximum as box operation",N,[[["array"],["u64"],["u64"],["bordertype"]],["array"]]],[5,"gaussian_kernel","","Creates a Gaussian Kernel.",N,[[["i32"],["i32"],["f64"],["f64"]],["array",["f32"]]]],[5,"color_space","","Color space conversion",N,[[["array"],["colorspace"],["colorspace"]],["array"]]],[5,"regions","","Find blobs in given image.",N,[[["array"],["connectivity"]],["array"]]],[5,"sobel","","Sobel Operator",N,N],[5,"hist_equal","","Histogram Equalization",N,[[["array"],["array"]],["array"]]],[5,"rgb2gray","","Color(RGB) to Grayscale conversion",N,[[["array"],["f32"],["f32"],["f32"]],["array"]]],[5,"gray2rgb","","Grayscale to Color(RGB) conversion",N,[[["array"],["f32"],["f32"],["f32"]],["array"]]],[5,"hsv2rgb","","HSV to RGB color space conversion",N,[[["array"]],["array"]]],[5,"rgb2hsv","","RGB to HSV color space conversion",N,[[["array"]],["array"]]],[5,"unwrap","","Generate an array with image windows as columns",N,[[["array"],["i64"],["i64"],["i64"],["i64"],["i64"],["i64"],["bool"]],["array"]]],[5,"wrap","","Converts unwrapped image to an image",N,[[["array"],["i64"],["i64"],["i64"],["i64"],["i64"],["i64"],["i64"],["i64"],["bool"]],["array"]]],[5,"sat","","Summed area table of an Image",N,[[["array"]],["array"]]],[5,"rgb2ycbcr","","RGB to YCbCr colorspace converter.",N,[[["array"],["yccstd"]],["array"]]],[5,"ycbcr2rgb","","YCbCr to RGB colorspace converter.",N,[[["array"],["yccstd"]],["array"]]],[5,"is_imageio_available","","Function to check if Image I/O is available",N,[[],["bool"]]],[5,"transform_coords","","Transform input coordinates",N,[[["array"],["f32"],["f32"]],["array"]]],[5,"moments","","Find Image moments",N,[[["array"],["momenttype"]],["array",["f32"]]]],[5,"moments_all","","Find Image moment for whole image",N,[[["array"],["momenttype"]],["f64"]]],[5,"medfilt1","","One dimensional median filter on image",N,[[["array"],["u64"],["bordertype"]],["array"]]],[5,"canny","","Canny edge detection operator",N,[[["array"],["cannythresholdtype"],["f32"],["f32"],["u32"],["bool"]],["array",["bool"]]]],[5,"anisotropic_diffusion","","Anisotropic smoothing filter",N,[[["array"],["f32"],["f32"],["u32"],["fluxfn"],["diffusioneq"]],["array"]]],[5,"svd","","Perform Singular Value Decomposition",N,N],[5,"svd_inplace","","Perform Singular Value Decomposition inplace",N,N],[5,"lu","","Perform LU decomposition",N,N],[5,"lu_inplace","","Perform inplace LU decomposition",N,[[["array"],["bool"]],["array",["i32"]]]],[5,"qr","","Perform QR decomposition",N,N],[5,"qr_inplace","","Perform inplace QR decomposition",N,[[["array"]],["array"]]],[5,"cholesky","","Perform Cholesky decomposition",N,N],[5,"cholesky_inplace","","Perform inplace Cholesky decomposition",N,[[["array"],["bool"]],["i32"]]],[5,"solve","","Solve a system of equations",N,[[["array"],["array"],["matprop"]],["array"]]],[5,"solve_lu","","Solve a system of equations",N,[[["array"],["array"],["array"],["matprop"]],["array"]]],[5,"inverse","","Compute inverse of a matrix",N,[[["array"],["matprop"]],["array"]]],[5,"rank","","Find rank of a matrix",N,[[["array"],["f64"]],["u32"]]],[5,"det","","Find the determinant of the matrix",N,N],[5,"norm","","Find the norm of a matrix",N,[[["array"],["normtype"],["f64"],["f64"]],["f64"]]],[5,"is_lapack_available","","Function to check if lapack support is available",N,[[],["bool"]]],[5,"set_seed","","Set seed for random number generation",N,[[["u64"]]]],[5,"get_seed","","Get the seed of random number generator",N,[[],["u64"]]],[5,"randu","","Create random numbers from uniform distribution",N,[[["dim4"]],["array"]]],[5,"randn","","Create random numbers from normal distribution",N,[[["dim4"]],["array"]]],[5,"get_default_random_engine","","Get default random engine",N,[[],["randomengine"]]],[5,"set_default_random_engine_type","","Set the random engine type for default random number generator",N,[[["randomenginetype"]]]],[5,"random_uniform","","Generate array of uniform numbers using a random engine",N,[[["dim4"],["randomengine"]],["array"]]],[5,"random_normal","","Generate array of normal numbers using a random engine",N,[[["dim4"],["randomengine"]],["array"]]],[5,"approx1","","Perform signal interpolation for 1d signals",N,[[["array"],["array"],["interptype"],["f32"]],["array"]]],[5,"approx2","","Perform signal interpolation for 2d signals",N,[[["array"],["array"],["array"],["interptype"],["f32"]],["array"]]],[5,"set_fft_plan_cache_size","","Set fft plan cache size",N,[[["usize"]]]],[5,"fft","","Fast fourier transform for 1d signals",N,[[["array"],["f64"],["i64"]],["array"]]],[5,"fft2","","Fast fourier transform for 2d signals",N,[[["array"],["f64"],["i64"],["i64"]],["array"]]],[5,"fft3","","Fast fourier transform for 3d signals",N,[[["array"],["f64"],["i64"],["i64"],["i64"]],["array"]]],[5,"ifft","","Inverse fast fourier transform for 1d signals",N,[[["array"],["f64"],["i64"]],["array"]]],[5,"ifft2","","Inverse fast fourier transform for 2d signals",N,[[["array"],["f64"],["i64"],["i64"]],["array"]]],[5,"ifft3","","Inverse fast fourier transform for 3d signals",N,[[["array"],["f64"],["i64"],["i64"],["i64"]],["array"]]],[5,"convolve1","","1d convolution",N,[[["array"],["array"],["convmode"],["convdomain"]],["array"]]],[5,"convolve2","","2d convolution",N,[[["array"],["array"],["convmode"],["convdomain"]],["array"]]],[5,"convolve3","","3d convolution",N,[[["array"],["array"],["convmode"],["convdomain"]],["array"]]],[5,"convolve2_sep","","Separable convolution for 2d signals",N,[[["array"],["array"],["array"],["convmode"]],["array"]]],[5,"fft_convolve1","","1d convolution using fast-fourier transform",N,[[["array"],["array"],["convmode"]],["array"]]],[5,"fft_convolve2","","2d convolution using fast-fourier transform",N,[[["array"],["array"],["convmode"]],["array"]]],[5,"fft_convolve3","","3d convolution using fast-fourier transform",N,[[["array"],["array"],["convmode"]],["array"]]],[5,"fir","","Finite impulse filter",N,[[["array"],["array"]],["array"]]],[5,"iir","","Infinite impulse response filter",N,[[["array"],["array"],["array"]],["array"]]],[5,"fft_inplace","","In place 1d dimensional Fast fourier transform",N,[[["array"],["f64"]]]],[5,"fft2_inplace","","In place 2d dimensional Fast fourier transform",N,[[["array"],["f64"]]]],[5,"fft3_inplace","","In place 3d dimensional Fast fourier transform",N,[[["array"],["f64"]]]],[5,"ifft_inplace","","In place 1d dimensional inverse fast fourier transform",N,[[["array"],["f64"]]]],[5,"ifft2_inplace","","In place 2d dimensional inverse fast fourier transform",N,[[["array"],["f64"]]]],[5,"ifft3_inplace","","In place 3d dimensional inverse fast fourier transform",N,[[["array"],["f64"]]]],[5,"fft_r2c","","1d Real to Complex fast fourier transform",N,[[["array"],["f64"],["i64"]],["array",["complex"]]]],[5,"fft2_r2c","","2d Real to Complex fast fourier transform",N,[[["array"],["f64"],["i64"],["i64"]],["array",["complex"]]]],[5,"fft3_r2c","","3d Real to Complex fast fourier transform",N,[[["array"],["f64"],["i64"],["i64"],["i64"]],["array",["complex"]]]],[5,"fft_c2r","","1d Complex to Real fast fourier transform",N,[[["array"],["f64"],["bool"]],["array"]]],[5,"fft2_c2r","","2d Complex to Real fast fourier transform",N,[[["array"],["f64"],["bool"]],["array"]]],[5,"fft3_c2r","","3d Complex to Real fast fourier transform",N,[[["array"],["f64"],["bool"]],["array"]]],[5,"sparse","","Create sprase matrix from arrays",N,[[["u64"],["u64"],["array"],["array"],["array"],["sparseformat"]],["array"]]],[5,"sparse_from_host","","Create sprase matrix from data on host memory",N,N],[5,"sparse_from_dense","","Convert dense array to sparse array",N,[[["array"],["sparseformat"]],["array"]]],[5,"sparse_convert_to","","Convert between sparse formats",N,[[["array"],["sparseformat"]],["array"]]],[5,"sparse_to_dense","","Convert sparse array to dense array",N,[[["array"]],["array"]]],[5,"sparse_get_info","","Get sparse Array information",N,N],[5,"sparse_get_values","","Get values of sparse Array",N,[[["array"]],["array"]]],[5,"sparse_get_row_indices","","Get row indices Array",N,[[["array"]],["array",["i32"]]]],[5,"sparse_get_col_indices","","Get cololumn indices Array",N,[[["array"]],["array",["i32"]]]],[5,"sparse_get_nnz","","Get number of non-zero elements in sparse array",N,[[["array"]],["i64"]]],[5,"sparse_get_format","","Get sparse format",N,[[["array"]],["sparseformat"]]],[5,"median","","Find the median along a given dimension",N,[[["array"],["i64"]],["array"]]],[5,"mean","","Mean along specified dimension",N,[[["array"],["i64"]],["array"]]],[5,"stdev","","Standard deviation along specified dimension",N,[[["array"],["i64"]],["array"]]],[5,"mean_weighted","","Weighted mean along specified dimension",N,[[["array"],["array"],["i64"]],["array"]]],[5,"var_weighted","","Weight variance along specified dimension",N,[[["array"],["array"],["i64"]],["array"]]],[5,"var","","Compute Variance along a specific dimension",N,[[["array"],["bool"],["i64"]],["array"]]],[5,"cov","","Compute covariance of two Arrays",N,[[["array"],["array"],["bool"]],["array"]]],[5,"var_all","","Compute Variance of all elements",N,N],[5,"mean_all","","Compute mean of all data",N,N],[5,"stdev_all","","Compute standard deviation of all data",N,N],[5,"median_all","","Compute median of all data",N,N],[5,"mean_all_weighted","","Compute weighted mean of all data",N,N],[5,"var_all_weighted","","Compute weighted variance of all data",N,N],[5,"corrcoef","","Compute correlation coefficient",N,N],[5,"topk","","Find top k elements along a given dimension",N,N],[5,"get_size","","Get size, in bytes, of the arrayfire native type",N,[[["dtype"]],["usize"]]],[5,"fast","","Fast feature detector",N,[[["array"],["f32"],["u32"],["bool"],["f32"],["u32"]],["features"]]],[5,"harris","","Harris corner detector.",N,[[["array"],["u32"],["f32"],["f32"],["u32"],["f32"]],["features"]]],[5,"orb","","ORB feature descriptor",N,N],[5,"hamming_matcher","","Hamming feature matcher",N,N],[5,"nearest_neighbour","","Nearest Neighbour.",N,N],[5,"match_template","","Image matching",N,[[["array"],["array"],["matchtype"]],["array"]]],[5,"susan","","SUSAN corner detector.",N,[[["array"],["u32"],["f32"],["f32"],["f32"],["u32"]],["features"]]],[5,"dog","","Difference of Gaussians.",N,[[["array"],["i32"],["i32"]],["array"]]],[5,"homography","","Homography estimation",N,N],[11,"new","","Constructs a new Array object",25,N],[11,"new_strided","","Constructs a new Array object from strided data",25,N],[11,"new_empty","","Constructs a new Array object of specified dimensions and type",25,[[["dim4"]],["array"]]],[11,"get_backend","","Returns the backend of the Array",25,[[["self"]],["backend"]]],[11,"get_device_id","","Returns the device identifier(integer) on which the Array was created",25,[[["self"]],["i32"]]],[11,"elements","","Returns the number of elements in the Array",25,[[["self"]],["usize"]]],[11,"get_type","","Returns the Array data type",25,[[["self"]],["dtype"]]],[11,"dims","","Returns the dimensions of the Array",25,[[["self"]],["dim4"]]],[11,"strides","","Returns the strides of the Array",25,[[["self"]],["dim4"]]],[11,"numdims","","Returns the number of dimensions of the Array",25,[[["self"]],["u32"]]],[11,"offset","","Returns the offset to the pointer from where data begins",25,[[["self"]],["i64"]]],[11,"get","","Returns the native FFI handle for Rust object `Array`",25,[[["self"]],["i64"]]],[11,"host","","Copies the data from the Array to the mutable slice `data`",25,N],[11,"eval","","Evaluates any pending lazy expressions that represent the data in the Array object",25,[[["self"]]]],[11,"copy","","Makes an copy of the Array",25,[[["self"]],["array"]]],[11,"is_empty","","Check if Array is empty",25,[[["self"]],["bool"]]],[11,"is_scalar","","Check if Array is scalar",25,[[["self"]],["bool"]]],[11,"is_row","","Check if Array is a row",25,[[["self"]],["bool"]]],[11,"is_column","","Check if Array is a column",25,[[["self"]],["bool"]]],[11,"is_vector","","Check if Array is a vector",25,[[["self"]],["bool"]]],[11,"is_complex","","Check if Array is of complex type",25,[[["self"]],["bool"]]],[11,"is_double","","Check if Array's numerical type is of double precision",25,[[["self"]],["bool"]]],[11,"is_single","","Check if Array's numerical type is of single precision",25,[[["self"]],["bool"]]],[11,"is_real","","Check if Array is of real type",25,[[["self"]],["bool"]]],[11,"is_floating","","Check if Array is of single precision",25,[[["self"]],["bool"]]],[11,"is_integer","","Check if Array is of integral type",25,[[["self"]],["bool"]]],[11,"is_bool","","Check if Array is of boolean type",25,[[["self"]],["bool"]]],[11,"is_linear","","Check if Array's memory layout is continuous and one dimensional",25,[[["self"]],["bool"]]],[11,"is_owner","","Check if Array's memory is owned by it and not a view of another Array",25,[[["self"]],["bool"]]],[11,"cast","","Cast the Array data type to `target_type`",25,[[["self"]],["array"]]],[11,"is_sparse","","Find if the current array is sparse",25,[[["self"]],["bool"]]],[11,"lock","","Lock the device buffer in the memory manager",25,[[["self"]]]],[11,"unlock","","Unlock the device buffer in the memory manager",25,[[["self"]]]],[11,"device_ptr","","Get the device pointer and lock the buffer in memory manager",25,[[["self"]],["u64"]]],[11,"get_allocated_bytes","","Get the size of physical allocated bytes.",25,[[["self"]],["usize"]]],[11,"clone","","",25,[[["self"]],["array"]]],[11,"drop","","",25,[[["self"]]]],[11,"add_assign","","",25,[[["self"],["array"]]]],[11,"sub_assign","","",25,[[["self"],["array"]]]],[11,"mul_assign","","",25,[[["self"],["array"]]]],[11,"div_assign","","",25,[[["self"],["array"]]]],[11,"rem_assign","","",25,[[["self"],["array"]]]],[11,"shl_assign","","",25,[[["self"],["array"]]]],[11,"shr_assign","","",25,[[["self"],["array"]]]],[11,"bitand_assign","","",25,[[["self"],["array"]]]],[11,"bitor_assign","","",25,[[["self"],["array"]]]],[11,"bitxor_assign","","",25,[[["self"],["array"]]]],[11,"convert","","",25,[[["self"]],["array"]]],[11,"add","","",25,N],[11,"sub","","",25,N],[11,"mul","","",25,N],[11,"div","","",25,N],[11,"add","","",25,N],[11,"sub","","",25,N],[11,"mul","","",25,N],[11,"div","","",25,N],[11,"add","","",25,N],[11,"sub","","",25,N],[11,"mul","","",25,N],[11,"div","","",25,N],[11,"add","","",25,N],[11,"sub","","",25,N],[11,"mul","","",25,N],[11,"div","","",25,N],[11,"add","","",25,N],[11,"sub","","",25,N],[11,"mul","","",25,N],[11,"div","","",25,N],[11,"add","","",25,N],[11,"sub","","",25,N],[11,"mul","","",25,N],[11,"div","","",25,N],[11,"add","","",25,N],[11,"sub","","",25,N],[11,"mul","","",25,N],[11,"div","","",25,N],[11,"add","","",25,N],[11,"sub","","",25,N],[11,"mul","","",25,N],[11,"div","","",25,N],[11,"add","","",25,N],[11,"sub","","",25,N],[11,"mul","","",25,N],[11,"div","","",25,N],[11,"add","","",25,N],[11,"add","","",25,N],[11,"sub","","",25,N],[11,"sub","","",25,N],[11,"mul","","",25,N],[11,"mul","","",25,N],[11,"div","","",25,N],[11,"div","","",25,N],[11,"rem","","",25,N],[11,"rem","","",25,N],[11,"shl","","",25,N],[11,"shl","","",25,N],[11,"shr","","",25,N],[11,"shr","","",25,N],[11,"bitand","","",25,N],[11,"bitand","","",25,N],[11,"bitor","","",25,N],[11,"bitor","","",25,N],[11,"bitxor","","",25,N],[11,"bitxor","","",25,N],[11,"neg","","",25,N],[11,"clone","","",0,[[["self"]],["aferror"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"eq","","",0,[[["self"],["aferror"]],["bool"]]],[11,"clone","","",1,[[["self"]],["backend"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"eq","","",1,[[["self"],["backend"]],["bool"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result",["fmterror"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result",["fmterror"]]]],[11,"description","","",0,[[["self"]],["str"]]],[11,"clone","","",2,[[["self"]],["dtype"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"eq","","",2,[[["self"],["dtype"]],["bool"]]],[11,"clone","","",3,[[["self"]],["interptype"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"eq","","",3,[[["self"],["interptype"]],["bool"]]],[11,"clone","","",4,[[["self"]],["bordertype"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"eq","","",4,[[["self"],["bordertype"]],["bool"]]],[11,"clone","","",5,[[["self"]],["connectivity"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"eq","","",5,[[["self"],["connectivity"]],["bool"]]],[11,"clone","","",6,[[["self"]],["convmode"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"eq","","",6,[[["self"],["convmode"]],["bool"]]],[11,"clone","","",7,[[["self"]],["convdomain"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"eq","","",7,[[["self"],["convdomain"]],["bool"]]],[11,"clone","","",8,[[["self"]],["matchtype"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"eq","","",8,[[["self"],["matchtype"]],["bool"]]],[11,"clone","","",9,[[["self"]],["colorspace"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"eq","","",9,[[["self"],["colorspace"]],["bool"]]],[11,"clone","","",10,[[["self"]],["matprop"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"eq","","",10,[[["self"],["matprop"]],["bool"]]],[11,"clone","","",11,[[["self"]],["normtype"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"eq","","",11,[[["self"],["normtype"]],["bool"]]],[11,"clone","","",12,[[["self"]],["colormap"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"eq","","",12,[[["self"],["colormap"]],["bool"]]],[11,"clone","","",13,[[["self"]],["yccstd"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"eq","","",13,[[["self"],["yccstd"]],["bool"]]],[11,"clone","","",14,[[["self"]],["homographytype"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"eq","","",14,[[["self"],["homographytype"]],["bool"]]],[11,"clone","","",15,[[["self"]],["markertype"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"eq","","",15,[[["self"],["markertype"]],["bool"]]],[11,"clone","","",16,[[["self"]],["momenttype"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"eq","","",16,[[["self"],["momenttype"]],["bool"]]],[11,"clone","","",17,[[["self"]],["sparseformat"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"eq","","",17,[[["self"],["sparseformat"]],["bool"]]],[11,"clone","","",18,[[["self"]],["binaryop"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"eq","","",18,[[["self"],["binaryop"]],["bool"]]],[11,"clone","","",19,[[["self"]],["randomenginetype"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"eq","","",19,[[["self"],["randomenginetype"]],["bool"]]],[11,"clone","","",20,[[["self"]],["scalar"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"eq","","",20,[[["self"],["scalar"]],["bool"]]],[11,"ne","","",20,[[["self"],["scalar"]],["bool"]]],[11,"clone","","",21,[[["self"]],["cannythresholdtype"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"eq","","",21,[[["self"],["cannythresholdtype"]],["bool"]]],[11,"clone","","",22,[[["self"]],["diffusioneq"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"eq","","",22,[[["self"],["diffusioneq"]],["bool"]]],[11,"clone","","",23,[[["self"]],["fluxfn"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"eq","","",23,[[["self"],["fluxfn"]],["bool"]]],[11,"clone","","",24,[[["self"]],["topkfn"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"eq","","",24,[[["self"],["topkfn"]],["bool"]]],[11,"clone","","",26,[[["self"]],["dim4"]]],[11,"eq","","",26,[[["self"],["dim4"]],["bool"]]],[11,"ne","","",26,[[["self"],["dim4"]],["bool"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"default","","",26,[[],["dim4"]]],[11,"index","","",26,[[["self"],["usize"]],["u64"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"new","","Create Dim4 object",26,N],[11,"elements","","Get the number of elements represented by Dim4 object",26,[[["self"]],["u64"]]],[11,"ndims","","Get the number of dimensions of Dim4",26,[[["self"]],["usize"]]],[11,"get","","Get the dimensions as a slice of 4 values",26,N],[11,"new","","Associated function to create a new Callback object",27,[[["errorcallback"]],["self"]]],[11,"call","","call invokes the error callback with `error_code`.",27,[[["self"],["aferror"]]]],[11,"set","","",25,[[["self"],["indexer"],["u32"],["option",["bool"]]]]],[11,"set","","",28,[[["self"],["indexer"],["u32"],["option",["bool"]]]]],[11,"new","","Create a new Indexer object and set the dimension specific index objects later",29,[[],["indexer"]]],[11,"set_index","","Set either Array or Seq to index an Array along `idx` dimension",29,[[["self"],["t"],["u32"],["option",["bool"]]]]],[11,"len","","Get number of indexing objects set",29,[[["self"]],["usize"]]],[11,"get","","Get native(ArrayFire) resource handle",29,[[["self"]],["i64"]]],[11,"drop","","",29,[[["self"]]]],[11,"clone","","",28,[[["self"]],["seq"]]],[11,"default","","",28,[[],["self"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a `Seq` that goes from `begin` to `end` at a step size of `step`",28,[[["t"],["t"],["t"]],["self"]]],[11,"begin","","Get begin index of Seq",28,[[["self"]],["t"]]],[11,"end","","Get end index of Seq",28,[[["self"]],["t"]]],[11,"step","","Get step size of Seq",28,[[["self"]],["t"]]],[11,"clone","","",30,[[["self"]],["window"]]],[11,"from","","",30,[[["u64"]],["window"]]],[11,"drop","","",30,[[["self"]]]],[11,"new","","Creates new Window object",30,[[["i32"],["i32"],["string"]],["window"]]],[11,"set_position","","Set window starting position on the screen",30,[[["self"],["u32"],["u32"]]]],[11,"set_title","","Set window title",30,[[["self"],["string"]]]],[11,"set_visibility","","Set window visibility",30,[[["self"],["bool"]]]],[11,"set_size","","Set window size",30,[[["self"],["u32"],["u32"]]]],[11,"set_colormap","","Set color map to be used for rendering image, it can take one of the values of enum ColorMap",30,[[["self"],["colormap"]]]],[11,"is_closed","","Returns true if the window close is triggered by the user",30,[[["self"]],["bool"]]],[11,"grid","","Setup display layout in multiview mode",30,[[["self"],["i32"],["i32"]]]],[11,"show","","Used in multiview mode to swap back buffer with front buffer to show the recently rendered frame",30,[[["self"]]]],[11,"set_view","","Set the current sub-region to render",30,[[["self"],["i32"],["i32"]]]],[11,"set_axes_titles","","Set chart axes titles",30,[[["self"],["string"],["string"],["string"]]]],[11,"set_axes_limits_compute","","Set chart axes limits by computing limits from data",30,[[["self"],["array"],["array"],["option",["array"]],["bool"]]]],[11,"set_axes_limits_2d","","Set 2d chart axes limits",30,[[["self"],["f32"],["f32"],["f32"],["f32"],["bool"]]]],[11,"set_axes_limits_3d","","Set 3d chart axes limits",30,[[["self"],["f32"],["f32"],["f32"],["f32"],["f32"],["f32"],["bool"]]]],[11,"draw_image","","Render given Array as an image",30,[[["self"],["array"],["option",["string"]]]]],[11,"draw_plot2","","Render given two Array's `x` and `y` as a 2d line plot",30,[[["self"],["array"],["array"],["option",["string"]]]]],[11,"draw_plot3","","Render given Array's `x`, `y` and `z` as a 3d line plot",30,[[["self"],["array"],["array"],["array"],["option",["string"]]]]],[11,"draw_plot","","Render give Arrays of points as a 3d line plot",30,[[["self"],["array"],["option",["string"]]]]],[11,"draw_hist","","Render given Array as a histogram",30,[[["self"],["array"],["f64"],["f64"],["option",["string"]]]]],[11,"draw_surface","","Render give Arrays as 3d surface",30,[[["self"],["array"],["array"],["array"],["option",["string"]]]]],[11,"draw_scatter2","","Render given Arrays as 2d scatter plot",30,[[["self"],["array"],["array"],["markertype"],["option",["string"]]]]],[11,"draw_scatter3","","Render given Arrays as 3d scatter plot",30,[[["self"],["array"],["array"],["array"],["markertype"],["option",["string"]]]]],[11,"draw_scatter","","Render give Array as 3d scatter plot",30,[[["self"],["array"],["markertype"],["option",["string"]]]]],[11,"draw_vector_field2","","Render given Arrays as 2d vector field",30,[[["self"],["array"],["array"],["array"],["array"],["option",["string"]]]]],[11,"draw_vector_field3","","Render given Arrays as 3d vector field",30,[[["self"],["array"],["array"],["array"],["array"],["array"],["array"],["option",["string"]]]]],[11,"draw_vector_field","","Render given Array as vector field",30,[[["self"],["array"],["array"],["option",["string"]]]]],[11,"from","","",31,[[["i64"]],["randomengine"]]],[11,"new","","Create a new random engine object",31,[[["randomenginetype"],["option",["u64"]]],["randomengine"]]],[11,"get_type","","Get random engine type",31,[[["self"]],["randomenginetype"]]],[11,"set_type","","Get random engine type",31,[[["self"],["randomenginetype"]]]],[11,"set_seed","","Set seed for random engine",31,[[["self"],["u64"]]]],[11,"get_seed","","Get seed of the random engine",31,[[["self"]],["u64"]]],[11,"get","","Returns the native FFI handle for Rust object `RandomEngine`",31,[[["self"]],["i64"]]],[11,"clone","","",31,[[["self"]],["randomengine"]]],[11,"drop","","",31,[[["self"]]]],[11,"from","","",0,[[["i32"]],["aferror"]]],[11,"from","","",2,[[["u32"]],["dtype"]]],[11,"from","","",3,[[["u32"]],["interptype"]]],[11,"from","","",6,[[["u32"]],["convmode"]]],[11,"from","","",7,[[["u32"]],["convdomain"]]],[11,"from","","",8,[[["u32"]],["matchtype"]]],[11,"from","","",12,[[["u32"]],["colormap"]]],[11,"from","","",17,[[["u32"]],["sparseformat"]]],[11,"from","","",18,[[["u32"]],["binaryop"]]],[11,"from","","",19,[[["u32"]],["randomenginetype"]]],[11,"new","","Create and return an object of type Features",32,[[["u64"]],["features"]]],[11,"num_features","","Get total number of features found",32,[[["self"]],["i64"]]],[11,"xpos","","Get x coordinates Array",32,[[["self"]],["array",["f32"]]]],[11,"ypos","","Get y coordinates Array",32,[[["self"]],["array",["f32"]]]],[11,"score","","Get score Array",32,[[["self"]],["array",["f32"]]]],[11,"orientation","","Get orientation Array",32,[[["self"]],["array",["f32"]]]],[11,"size","","Get features size Array",32,[[["self"]],["array",["f32"]]]],[11,"get","","Get the internal handle for Features object",32,[[["self"]],["i64"]]],[11,"clone","","",32,[[["self"]],["features"]]],[11,"drop","","",32,[[["self"]]]],[6,"ErrorCallback","","Signature of error handling callback function",N,N],[17,"PHILOX","","Default Philon RandomEngine that points to PHILOX_4X32_10",N,N],[17,"THREEFRY","","Default Threefry RandomEngine that points to THREEFRY_2X32_16",N,N],[17,"MERSENNE","","Default Mersenne RandomEngine that points to MERSENNE_GP11213",N,N],[17,"DEFAULT_RANDOM_ENGINE","","Default RandomEngine that defaults to PHILOX",N,N],[8,"Convertable","","Type Trait to convert to an Array",N,N],[16,"OutType","","This type alias always points to `Self` which is the type of Array returned by the trait method convert.",33,N],[10,"convert","","Get an Array of implementors type",33,[[["self"]],["array"]]],[8,"ConstGenerator","","Type Trait to generate a constant Array of given size",N,N],[16,"OutType","","The type of Array object returned by generate function",34,N],[10,"generate","","Create an Array of `dims` size from scalar value `self`.",34,[[["self"],["dim4"]],["array"]]],[8,"Indexable","","Trait bound indicating indexability",N,N],[10,"set","","Set indexing object for a given dimension",35,[[["self"],["indexer"],["u32"],["option",["bool"]]]]],[8,"HasAfEnum","","Types of the data that can be generated using ArrayFire data generation functions.",N,N],[16,"InType","","This type alias points to `Self` always.",36,N],[16,"BaseType","","This type alias points to the data type used to hold real part of a complex number. For real valued numbers, this points to `Self`.",36,N],[16,"AbsOutType","","This type alias points to `f32` for all 32 bit size types and `f64` for larger 64-bit size types.",36,N],[16,"ArgOutType","","This type alias points to `f64`/`f32` for floating point types and `Self` otherwise.",36,N],[16,"UnaryOutType","","This type alias is used to define the output Array type for unary operations. It points to `Self` for floating point types, either real or complex. It points to `f32` for rest of the input types.",36,N],[16,"ComplexOutType","","This type alias points to complex type created from a given input type. This alias always points to either `std::Complex<f32>` or `std::Complex<f64>`",36,N],[16,"MeanOutType","","This type alias points to a data type that can store the mean value for a given input type. This alias points to `f32`/`Complex<f32>` for all 32 bit size types and `f64`/`Complex<f64>` for larger 64-bit size types.",36,N],[16,"AggregateOutType","","This type alias points to a data type that can store the result of aggregation of set of values for a given input type. Aggregate type alias points to below types for given input types: - `Self` for input types: `Complex<64>`, `Complex<f32>`, `f64`, `f32`, `i64`, `u64` - `f32` for input types: `bool` - `u32` for input types: `u8` - `i32` for input types: `i16` - `u32` for input types: `u16` - `i32` for input types: `i32` - `u32` for input types: `u32`",36,N],[16,"SobelOutType","","This type alias points to the output type for given input type of sobel filter operation. Sobel filter output alias points to below types for given input types: - `f32` for input types: `Complex<f32>`, `f32` - `f64` for input types: `Complex<f64>`, `f64` - `i32` for input types: `bool`, `u8`, `i16`, `u16`, `i32`, `u32` - `i64` for input types: `i64`, `u64`",36,N],[10,"get_af_dtype","","Return trait implmentors corresponding DType",36,[[],["dtype"]]],[8,"ImplicitPromote","","This is an internal trait defined and implemented by ArrayFire create for rust's built-in types to figure out the data type binary operation's results.",N,N],[16,"Output","","This type alias points to the type of the result obtained by performing a given binary option on given type and `RHS`.",37,N],[14,"mem_info","","Macro to print the current stats of ArrayFire's memory manager.",N,N],[14,"join_many","","Join multiple Arrays along a given dimension",N,N],[14,"af_print","","Print given message before printing out the Array to standard output",N,N],[14,"eval","","Evaluate arbitrary number of arrays",N,N]],"paths":[[4,"AfError"],[4,"Backend"],[4,"DType"],[4,"InterpType"],[4,"BorderType"],[4,"Connectivity"],[4,"ConvMode"],[4,"ConvDomain"],[4,"MatchType"],[4,"ColorSpace"],[4,"MatProp"],[4,"NormType"],[4,"ColorMap"],[4,"YCCStd"],[4,"HomographyType"],[4,"MarkerType"],[4,"MomentType"],[4,"SparseFormat"],[4,"BinaryOp"],[4,"RandomEngineType"],[4,"Scalar"],[4,"CannyThresholdType"],[4,"DiffusionEq"],[4,"FluxFn"],[4,"TopkFn"],[3,"Array"],[3,"Dim4"],[3,"Callback"],[3,"Seq"],[3,"Indexer"],[3,"Window"],[3,"RandomEngine"],[3,"Features"],[8,"Convertable"],[8,"ConstGenerator"],[8,"Indexable"],[8,"HasAfEnum"],[8,"ImplicitPromote"]]};
initSearch(searchIndex);
