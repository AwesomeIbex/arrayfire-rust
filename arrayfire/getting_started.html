<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Getting Started</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
<link rel="stylesheet" type="text/css" href="../main.css">
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../external_docs.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <h1 class="title">Getting Started</h1>
    <nav id="TOC"><ul>
<li><a href="#introduction">1 Introduction</a><ul></ul></li>
<li><a href="#supported-data-types">2 Supported data types</a><ul></ul></li>
<li><a href="#creating-and-populating-an-arrayfire-array">3 Creating and populating an ArrayFire array</a><ul></ul></li>
<li><a href="#arrayfire-array-contents-dimensions-and-properties">4 ArrayFire array contents, dimensions, and properties</a><ul></ul></li>
<li><a href="#writing-mathematical-expressions-using-arrayfire">5 Writing mathematical expressions using ArrayFire</a><ul></ul></li>
<li><a href="#indexing">6 Indexing</a><ul></ul></li>
<li><a href="#getting-access-to-arrayfire-array-memory-on-the-host">7 Getting access to ArrayFire array memory on the host</a><ul></ul></li>
<li><a href="#bitwise-operators">8 Bitwise operators</a><ul></ul></li>
<li><a href="#where-to-go-for-help">9 Where to go for help?</a><ul></ul></li></ul></nav><h1 id="introduction" class="section-header"><a href="#introduction">1 Introduction</a></h1>
<p>ArrayFire is a high performance software library for parallel computing with
an easy-to-use API. ArrayFire abstracts away much of the details of
programming parallel architectures by providing a high-level container object,
the <a href="./struct.Array.html">Array</a>, that represents data stored on a CPU, GPU, FPGA,
or other type of accelerator. This abstraction permits developers to write
massively parallel applications in a high-level language where they need
not be concerned about low-level optimizations that are frequently required to
achieve high throughput on most parallel architectures.</p>
<h1 id="supported-data-types" class="section-header"><a href="#supported-data-types">2 Supported data types</a></h1>
<p>ArrayFire provides one generic container object, the <a href="./struct.Array.html">Array</a>
on which functions and mathematical operations are performed. The <code>array</code>
can represent one of many different <a href="./enum.DType.html">basic data types</a>:</p>
<ul>
<li><a href="./enum.DType.html">F32</a> real single-precision (<code>float</code>)</li>
<li><a href="./enum.DType.html">C32</a> complex single-precision (<code>cfloat</code>)</li>
<li><a href="./enum.DType.html">F64</a> real double-precision (<code>double</code>)</li>
<li><a href="./enum.DType.html">C64</a> complex double-precision (<code>cdouble</code>)</li>
<li><a href="./enum.DType.html">B8 </a> 8-bit boolean values (<code>bool</code>)</li>
<li><a href="./enum.DType.html">S32</a> 32-bit signed integer (<code>int</code>)</li>
<li><a href="./enum.DType.html">U32</a> 32-bit unsigned integer (<code>unsigned</code>)</li>
<li><a href="./enum.DType.html">U8 </a> 8-bit unsigned values (<code>unsigned char</code>)</li>
<li><a href="./enum.DType.html">S64</a> 64-bit signed integer (<code>intl</code>)</li>
<li><a href="./enum.DType.html">U64</a> 64-bit unsigned integer (<code>uintl</code>)</li>
<li><a href="./enum.DType.html">S16</a> 16-bit signed integer (<code>short</code>)</li>
<li><a href="./enum.DType.html">U16</a> 16-bit unsigned integer (<code>unsigned short</code>)</li>
</ul>
<p>Most of these data types are supported on all modern GPUs; however, some
older devices may lack support for double precision arrays. In this case,
a runtime error will be generated when the array is constructed.</p>
<p>If not specified otherwise, <code>Array</code>s are created as single precision floating
point numbers (<a href="./enum.DType.html">F32</a>).</p>
<h1 id="creating-and-populating-an-arrayfire-array" class="section-header"><a href="#creating-and-populating-an-arrayfire-array">3 Creating and populating an ArrayFire array</a></h1>
<p>ArrayFire <a href="./struct.Array.html">Array</a>s represent memory stored on the device.
As such, creation and population of an array will consume memory on the device
which cannot freed until the <code>array</code> object goes out of scope. As device memory
allocation can be expensive, ArrayFire also includes a memory manager which
will re-use device memory whenever possible.</p>
<p>Arrays can be created using one of the <a href="./struct.Array.html#method.new_empty">array constructors</a>.
Below we show how to create 1D, 2D, and 3D arrays with uninitialized values:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">garbageVals</span> <span class="op">=</span> <span class="ident">Array</span>::<span class="ident">new_empty</span>(<span class="ident">Dim4</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]), <span class="ident">DType</span>::<span class="ident">F32</span>);</pre>
<p>However, uninitialized memory is likely not useful in your application.
ArrayFire provides several convenient functions for creating arrays that contain
pre-populated values including constants, uniform random numbers, uniform
normally distributed numbers, and the identity matrix:</p>

<pre class="rust rust-example-rendered">
<span class="comment">// Create an array filled with constant value of 2.0 of type floating point</span>
<span class="comment">// The type of Array is infered from the type of the constant argument</span>
<span class="kw">let</span> <span class="ident">cnst</span> <span class="op">=</span> <span class="ident">constant</span>(<span class="number">2.0f32</span>, <span class="ident">Dim4</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span>[<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>]));
<span class="ident">print</span>(<span class="kw-2">&amp;</span><span class="ident">cnst</span>);</pre>

<pre class="rust rust-example-rendered">
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Create a 5-by-3 matrix of random floats on the GPU&quot;</span>);
<span class="kw">let</span> <span class="ident">dims</span> <span class="op">=</span> <span class="ident">Dim4</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span>[<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>]);
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">randu</span>::<span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span>(<span class="ident">dims</span>);
<span class="ident">print</span>(<span class="kw-2">&amp;</span><span class="ident">a</span>);</pre>
<p>As stated above, the default data type for arrays is <a href="./enum.DType.html">F32</a> (a
32-bit floating point number) unless specified otherwise.</p>
<p>ArrayFire <code>Array</code>s may also be populated from data found on the host.
For example:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">values</span>: [<span class="ident">u32</span>; <span class="number">3</span>] <span class="op">=</span> [<span class="number">1u32</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">indices</span> <span class="op">=</span> <span class="ident">Array</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">values</span>, <span class="ident">Dim4</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]));
<span class="ident">print</span>(<span class="kw-2">&amp;</span><span class="ident">indices</span>);</pre>
<!--
ArrayFire also supports array initialization from memory already on the GPU.
For example, with CUDA one can populate an `array` directly using a call
to `cudaMemcpy`:
<p>\snippet test/getting_started.cpp ex_getting_started_dev_ptr</p>
<p>Similar functionality exists for OpenCL too. If you wish to intermingle
ArrayFire with CUDA or OpenCL code, we suggest you consult the
[CUDA interoperability](\ref interop_cuda) or
[OpenCL interoperability](\ref interop_opencl) pages for detailed instructions.
--&gt;</p>
<h1 id="arrayfire-array-contents-dimensions-and-properties" class="section-header"><a href="#arrayfire-array-contents-dimensions-and-properties">4 ArrayFire array contents, dimensions, and properties</a></h1>
<p>ArrayFire provides several functions to determine various aspects of arrays.
This includes functions to print the contents, query the dimensions, and
determine various other aspects of arrays.</p>
<p>The <a href="./fn.print.html">print</a> function can be used to print arrays that
have already been generated or any expression involving arrays:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">values</span>: [<span class="ident">f32</span>; <span class="number">3</span>] <span class="op">=</span> [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>];
<span class="kw">let</span> <span class="ident">indices</span> <span class="op">=</span> <span class="ident">Array</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">values</span>, <span class="ident">Dim4</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]));
<span class="ident">print</span>(<span class="kw-2">&amp;</span><span class="ident">indices</span>);</pre>
<p>The dimensions of an array may be determined using either a <a href="./struct.Dim4.html">Dim4</a> object or by accessing the dimensions directly using the <a href="./struct.Dim4.html#method.get">Dim4::get</a> and <a href="./struct.Dim4.html#method.ndims">Dim4::numdims</a> functions:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">values</span>: [<span class="ident">f32</span>; <span class="number">3</span>] <span class="op">=</span> [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>];
<span class="kw">let</span> <span class="ident">dims</span>: <span class="ident">Dim4</span> <span class="op">=</span> <span class="ident">Dim4</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);
<span class="kw">let</span> <span class="ident">indices</span> <span class="op">=</span> <span class="ident">Array</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">values</span>, <span class="ident">dims</span>);
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Dims {:?} with dimensions {}&quot;</span>, <span class="ident">dims</span>.<span class="ident">get</span>(), <span class="ident">dims</span>.<span class="ident">ndims</span>());</pre>
<p>In addition to dimensions, arrays also carry several properties including
methods to determine the underlying type and size (in bytes). You can even
determine whether the array is empty, real/complex, a row/column, or a scalar
or a vector. For further information on these capabilities, we suggest you consult the
full documentation on the <a href="./struct.Array.html">Array</a>.</p>
<h1 id="writing-mathematical-expressions-using-arrayfire" class="section-header"><a href="#writing-mathematical-expressions-using-arrayfire">5 Writing mathematical expressions using ArrayFire</a></h1>
<p>ArrayFire features an intelligent Just-In-Time (JIT) compilation engine that
converts expressions using arrays into the smallest number of CUDA/OpenCL
kernels. For most operations on Arrays, ArrayFire functions like a vector library.
That means that an element-wise operation, like <code>c[i] = a[i] + b[i]</code> in C,
would be written more concisely without indexing, like <code>c = a + b</code>.
When there are multiple expressions involving arrays, ArrayFire's JIT engine
will merge them together. This &quot;kernel fusion&quot; technology not only decreases
the number of kernel calls, but, more importantly, avoids extraneous global
memory operations.</p>
<p>Our JIT functionality extends across C API boundary and only ends
when a non-JIT function is encountered or a synchronization operation is
explicitly called by the code.</p>
<p>ArrayFire provides hundreds of functions for element-wise
operations. All of the standard operators (e.g. +,-,*,/) are supported
as are most transcendental functions (sin, cos, log, sqrt, etc.).
Here are a few examples:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">num_rows</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="number">5</span>;
<span class="kw">let</span> <span class="ident">num_cols</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="number">3</span>;
<span class="kw">let</span> <span class="ident">dims</span> <span class="op">=</span> <span class="ident">Dim4</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span>[<span class="ident">num_rows</span>, <span class="ident">num_cols</span>, <span class="number">1</span>, <span class="number">1</span>]);
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">randu</span>::<span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span>(<span class="ident">dims</span>);
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">randu</span>::<span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span>(<span class="ident">dims</span>);
<span class="ident">print</span>(<span class="kw-2">&amp;</span><span class="ident">a</span>);
<span class="ident">print</span>(<span class="kw-2">&amp;</span><span class="ident">b</span>);
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">+</span> <span class="ident">b</span>;
<span class="ident">print</span>(<span class="kw-2">&amp;</span><span class="ident">c</span>);

<span class="comment">//Example of *Assign traits</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">d</span> <span class="op">=</span> <span class="ident">randu</span>::<span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span>(<span class="ident">dims</span>);
<span class="kw">let</span> <span class="ident">e</span>     <span class="op">=</span> <span class="ident">constant</span>(<span class="number">1f32</span>, <span class="ident">dims</span>);
<span class="ident">d</span> <span class="op">+=</span> <span class="ident">e</span>;
<span class="ident">print</span>(<span class="kw-2">&amp;</span><span class="ident">d</span>);</pre>
<!--To see the complete list of functions please refer to the documentation on
[mathematical](\ref mathfunc_mat), [linear algebra](\ref linalg_mat),
[signal processing](\ref signal_mat), and [statistics](\ref stats_mat).
-->
<h1 id="indexing" class="section-header"><a href="#indexing">6 Indexing</a></h1>
<p>Like all functions in ArrayFire, indexing is also executed in parallel on
the OpenCL/CUDA device. To index <code>af::array</code>s you may use one or a combination of the following functions:</p>
<ul>
<li><a href="./struct.Seq.html">Seq</a> representing a linear sequence</li>
<li><a href="./struct.Seq.html">Seq::Default()</a> representing the entire dimension</li>
<li><a href="./fn.row.html">row(&amp;Array, i)</a> or <a href="./fn.col.html">col(&amp;Array, i)</a> specifying a single row/column</li>
<li><a href="./fn.rows.html">rows(&amp;Array, first,last)</a> or <a href="./fn.cols.html">cols(&amp;Array, first,last)</a>
specifying a span of rows or columns</li>
</ul>
<p>Please see the <a href="./indexing.html">indexing page</a> for several examples of how to
use these functions.</p>
<h1 id="getting-access-to-arrayfire-array-memory-on-the-host" class="section-header"><a href="#getting-access-to-arrayfire-array-memory-on-the-host">7 Getting access to ArrayFire array memory on the host</a></h1>
<p>Memory in <code>af::Array</code>s may be accessed using the <a href="./struct.Array.html#method.host">Array::host()</a> method.
The <code>host</code> function <em>copies</em> the data from the device and makes it available
in a standard slice or similar container on the host. As such, it is up to the developer to manage
any memory returned by <code>host</code>.</p>
<!--
# Getting access to ArrayFire array memory on the host and device
<p>Memory in <code>af::array</code>s may be accessed using the [host()](\ref af::array::host)
and [device()](\ref af::array::device) functions.
The <code>host</code> function <em>copies</em> the data from the device and makes it available
in a C-style array on the host. As such, it is up to the developer to manage
any memory returned by <code>host</code>.
The <code>device</code> function returns a pointer/reference to device memory for
interoperability with external CUDA/OpenCL kernels. As this memory belongs to
ArrayFire, the programmer should not attempt to free/deallocate the pointer.
For example, here is how we can interact with both OpenCL and CUDA:</p>

<pre class="rust rust-example-rendered">
</pre>
<p>ArrayFire also provides several helper functions for creating <code>af::array</code>s from
OpenCL <code>cl_mem</code> references and <code>cl::Buffer</code> objects. See the <code>include/af/opencl.h</code>
file for further information.</p>
<p>Lastly, if you want only the first value from an <code>af::array</code> you can use
get it using the [scalar()](\ref af::array::scalar) function:</p>

<pre class="rust rust-example-rendered">
</pre>
<p>--&gt;</p>
<h1 id="bitwise-operators" class="section-header"><a href="#bitwise-operators">8 Bitwise operators</a></h1>
<p>In addition to supporting standard mathematical functions, Arrays
that contain integer data types also support bitwise operators including
and, or, and shift etc.</p>
<h1 id="where-to-go-for-help" class="section-header"><a href="#where-to-go-for-help">9 Where to go for help?</a></h1>
<ul>
<li><a href="https://groups.google.com/forum/#!forum/arrayfire-users">Google Groups</a></li>
<li>ArrayFire Services:  <a href="http://arrayfire.com/consulting/">Consulting</a>  |  <a href="http://arrayfire.com/support/">Support</a>   |  <a href="http://arrayfire.com/training/">Training</a></li>
<li><a href="http://arrayfire.com/blog/">ArrayFire Blogs</a></li>
<li>Email: <a href="mailto:technical@arrayfire.com">mailto:technical@arrayfire.com</a></li>
</ul>

    
</body>
</html>