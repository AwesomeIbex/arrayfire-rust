<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Vectorization</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
<link rel="stylesheet" type="text/css" href="../main.css">
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../external_docs.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <h1 class="title">Vectorization</h1>
    <!--
Programmers and Data Scientists want to take advantage of fast and parallel
computational devices. Writing vectorized code is necessary to get
the best performance out of the current generation parallel hardware and
scientific computing software. However, writing vectorized code may not be
immediately intuitive. ArrayFire provides many ways to vectorize a given code
segment. In this tutorial, we present several methods to vectorize code
using ArrayFire and discuss the benefits and drawbacks associated with each method.
<h3 id="genericdefault-vectorization" class="section-header"><a href="#genericdefault-vectorization">Generic/Default vectorization</a></h3>
<p>--&gt;
By its very nature, ArrayFire is a vectorized library. Most functions operate on
Arrays as a whole -- on all elements in parallel. For example consider the following code:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">af</span>::<span class="ident">range</span>(<span class="ident">Dim</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]));  <span class="comment">// [0,  9]</span>
<span class="ident">a</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">+</span> <span class="number">1</span>;                                        <span class="comment">// [1, 10]</span></pre></div>
<p>This code will result in a single backend kernel that operates on all 10 elements
of <code>a</code> in  parallel.</p>
<p>A small subset of such vectorized ArrayFire functions are given below for quick reference:</p>
<table><thead><tr><th>  Operator Category                                           </th><th> Functions                  </th></tr></thead><tbody>
<tr><td>  Arithmetic operations                    </td><td> +, -, *, /, %, &gt;&gt;, &lt;&lt; </td></tr>
<tr><td>  Logical operations                       </td><td> &amp;&amp;, ||, &lt;, &gt;, ==, != etc. </td></tr>
<tr><td>  Numeric functions                        </td><td> <a href="./fn.abs.html">abs</a>, <a href="./fn.floor.html">floor</a>, <a href="./fn.round.html">round</a>, <a href="./fn.min.html">min</a>, <a href="./fn.max.html">max</a>, etc. </td></tr>
<tr><td>  Complex operations                       </td><td> <a href="./fn.real.html">real</a>, <a href="./fn.imag.html">imag</a>, <a href="./fn.conj.html">conj</a>, etc. </td></tr>
<tr><td>  Exponential and logarithmic functions    </td><td> <a href="./fn.exp.html">exp</a>, <a href="./fn.log.html">log</a>, <a href="./fn.expm1.html">expm1</a>, <a href="./fn.log1p.html">log1p</a>, etc. </td></tr>
<tr><td>  Trigonometric functions                  </td><td> <a href="./fn.sin.html">sin</a>, <a href="./fn.cos.html">cos</a>, <a href="./fn.tan.html">tan</a>, etc. </td></tr>
<tr><td>  Hyperbolic functions                     </td><td> <a href="./fn.sinh.html">sinh</a>, <a href="./fn.cosh.html">cosh</a>, <a href="./fn.tanh.html">tanh</a>, etc. </td></tr>
</tbody></table>
<p>In addition to element-wise operations, many other functions are also
vectorized in ArrayFire.</p>
<p>Notice that even functions that perform some form of aggregation (e.g.
<a href="./fn.sum.html">sum</a> or <a href="./fn.min.html">min</a>), signal processing (like
<a href="./fn.convolve.html">convolve</a>), and image processing functions
(i.e. <a href="./fn.rotate.html">rotate</a> etc.) - all support vectorization on
different columns or images.</p>
<p>For example, if we have <code>NUM</code> images of size <code>WIDTH</code>x<code>HEIGHT</code>, one could
convolve each image in a vector fashion as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">g_coef</span>: [<span class="ident">f32</span>, <span class="number">9</span>] <span class="op">=</span> { <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> };

<span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">Array</span>::<span class="ident">new</span>(<span class="ident">g_coef</span>, <span class="ident">Dim4</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>]));
<span class="kw">let</span> <span class="ident">filter</span> <span class="op">=</span> <span class="ident">f</span> <span class="op">*</span> <span class="number">1.0f32</span><span class="op">/</span><span class="number">16</span>;

<span class="kw">let</span> <span class="ident">signal</span> <span class="op">=</span> <span class="ident">randu</span>(<span class="ident">WIDTH</span>, <span class="ident">HEIGHT</span>, <span class="ident">NUM</span>);
<span class="kw">let</span> <span class="ident">conv</span>   <span class="op">=</span> <span class="ident">convolve2</span>(<span class="ident">signal</span>, <span class="ident">filter</span>, <span class="ident">ConvMode</span>::<span class="ident">DEFAULT</span>, <span class="ident">ConvDomain</span>::<span class="ident">AUTO</span>);</pre></div>
<p>Similarly, one can rotate 100 images by 45 degrees in a single call using
code like the following:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Construct an array of 100 WIDTH x HEIGHT images of random numbers</span>
<span class="kw">let</span> <span class="ident">imgs</span> <span class="op">=</span> <span class="ident">randu</span>(<span class="ident">WIDTH</span>, <span class="ident">HEIGHT</span>, <span class="number">100</span>);

<span class="comment">// Rotate all of the images in a single command</span>
<span class="kw">let</span> <span class="ident">rot_imgs</span> <span class="op">=</span> <span class="ident">rotate</span>(<span class="ident">imgs</span>, <span class="number">45.0</span>, <span class="ident">False</span>, <span class="ident">InterpType</span>::<span class="ident">LINEAR</span>);</pre></div>
<p>Although <em>most</em> functions in ArrayFire do support vectorization, some do not.
Most notably, all linear algebra functions. Even though they are not vectorized
linear algebra operations still execute in parallel on your hardware.</p>
<p>Using the built in vectorized operations should be the first
and preferred method of vectorizing any code written with ArrayFire.</p>
<!--
# Batching
<p>The batchFunc() function allows the broad application of existing ArrayFire
functions to multiple sets of data. Effectively, batchFunc() allows ArrayFire
functions to execute in &quot;batch processing&quot; mode. In this mode, functions will
find a dimension which contains &quot;batches&quot; of data to be processed and will
parallelize the procedure.</p>
<p>Consider the following example. Here we create a filter which we would like
to apply to each of the weight vectors. The naive solution would be using a
for-loop as we have seen previously:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Create the filter and the weight vectors</span>
<span class="ident">af</span>::<span class="ident">array</span> <span class="ident">filter</span> <span class="op">=</span> <span class="ident">randn</span>(<span class="number">1</span>, <span class="number">5</span>);
<span class="ident">af</span>::<span class="ident">array</span> <span class="ident">weights</span> <span class="op">=</span> <span class="ident">randu</span>(<span class="number">5</span>, <span class="number">5</span>);

<span class="comment">// Apply the filter using a for-loop</span>
<span class="ident">af</span>::<span class="ident">array</span> <span class="ident">filtered_weights</span> <span class="op">=</span> <span class="ident">constant</span>(<span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>);
<span class="kw">for</span>(<span class="ident">int</span> <span class="ident">i</span><span class="op">=</span><span class="number">0</span>; <span class="ident">i</span><span class="op">&lt;</span><span class="ident">weights</span>.<span class="ident">dims</span>(<span class="number">1</span>); <span class="op">+</span><span class="op">+</span><span class="ident">i</span>){
    <span class="ident">filtered_weights</span>.<span class="ident">col</span>(<span class="ident">i</span>) <span class="op">=</span> <span class="ident">filter</span> <span class="op">*</span> <span class="ident">weights</span>.<span class="ident">col</span>(<span class="ident">i</span>);
}</pre></div>
<p>However, as we have discussed above, this solution will be very inefficient.
One may be tempted to implement a vectorized solution as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Create the filter and the weight vectors</span>
<span class="ident">af</span>::<span class="ident">array</span> <span class="ident">filter</span> <span class="op">=</span> <span class="ident">randn</span>(<span class="number">1</span>, <span class="number">5</span>);
<span class="ident">af</span>::<span class="ident">array</span> <span class="ident">weights</span> <span class="op">=</span> <span class="ident">randu</span>(<span class="number">5</span>, <span class="number">5</span>);

<span class="ident">af</span>::<span class="ident">array</span> <span class="ident">filtered_weights</span> <span class="op">=</span> <span class="ident">filter</span> <span class="op">*</span> <span class="ident">weights</span>; <span class="comment">// fails due to dimension mismatch</span></pre></div>
<p>However, the dimensions of <code>filter</code> and <code>weights</code> do not match, thus ArrayFire
will generate a runtime error.</p>
<p><code>batchfunc()</code> was created to solve this specific problem.
The signature of the function is as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">array</span> <span class="ident">batchFunc</span>(<span class="kw">const</span> <span class="ident">array</span> <span class="kw-2">&amp;</span><span class="ident">lhs</span>, <span class="kw">const</span> <span class="ident">array</span> <span class="kw-2">&amp;</span><span class="ident">rhs</span>, <span class="ident">batchFunc_t</span> <span class="ident">func</span>);</pre></div>
<p>where <code>__batchFunc_t__</code> is a function pointer of the form:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">typedef</span> <span class="ident">array</span> (<span class="kw-2">*</span><span class="ident">batchFunc_t</span>) (<span class="kw">const</span> <span class="ident">array</span> <span class="kw-2">&amp;</span><span class="ident">lhs</span>, <span class="kw">const</span> <span class="ident">array</span> <span class="kw-2">&amp;</span><span class="ident">rhs</span>);</pre></div>
<p>So, to use batchFunc(), we need to provide the function we wish to apply as a
batch operation. For illustration's sake, let's &quot;implement&quot; a multiplication
function following the format.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">af</span>::<span class="ident">array</span> <span class="ident">my_mult</span> (<span class="kw">const</span> <span class="ident">af</span>::<span class="ident">array</span> <span class="kw-2">&amp;</span><span class="ident">lhs</span>, <span class="kw">const</span> <span class="ident">af</span>::<span class="ident">array</span> <span class="kw-2">&amp;</span><span class="ident">rhs</span>){
    <span class="kw">return</span> <span class="ident">lhs</span> <span class="op">*</span> <span class="ident">rhs</span>;
}</pre></div>
<p>Our final batch call is not much more difficult than the ideal
syntax we imagined.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Create the filter and the weight vectors</span>
<span class="ident">af</span>::<span class="ident">array</span> <span class="ident">filter</span> <span class="op">=</span> <span class="ident">randn</span>(<span class="number">1</span>, <span class="number">5</span>);
<span class="ident">af</span>::<span class="ident">array</span> <span class="ident">weights</span> <span class="op">=</span> <span class="ident">randu</span>(<span class="number">5</span>, <span class="number">5</span>);

<span class="comment">// Apply the batch function</span>
<span class="ident">af</span>::<span class="ident">array</span> <span class="ident">filtered_weights</span> <span class="op">=</span> <span class="ident">batchFunc</span>( <span class="ident">filter</span>, <span class="ident">weights</span>, <span class="ident">my_mult</span> );</pre></div>
<p>The batch function will work with many previously mentioned vectorized ArrayFire
functions. It can even work with a combination of those functions if they are
wrapped inside a helper function matching the <code>__batchFunc_t__</code> signature.
One limitation of <code>batchfunc()</code> is that it cannot be used from within a
<code>gfor()</code> loop at the present time.</p>
<h1 id="advanced-vectorization" class="section-header"><a href="#advanced-vectorization">Advanced Vectorization</a></h1>
<p>We have seen the different methods ArrayFire provides to vectorize our code. Tying
them all together is a slightly more involved process that needs to consider data
dimensionality and layout, memory usage, nesting order, etc. An excellent example
and discussion of these factors can be found on our blog:</p>
<p>http://arrayfire.com/how-to-write-vectorized-code/</p>
<p>It's worth noting that the content discussed in the blog has since been transformed
into a convenient af::nearestNeighbour() function. Before writing something from
scratch, check that ArrayFire doesn't already have an implementation. The default
vectorized nature of ArrayFire and an extensive collection of functions will
speed things up in addition to replacing dozens of lines of code!
--&gt;</p>

    
</body>
</html>